


[{"content":"","date":"2025年8月3日","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"大家好，我是 Cayden，今天给大家分享一个我刚上线的二维码生成工具：QrCay，市面上二维码工具其实已经很多了，我使用下来发现，虽然生成二维码的功能大家都做的很好，但是我每次生成完二维码，等我下次重新进来，发现我上次生成的二维码已经不见了，我需要重新生成，非常麻烦。\n很多工具都没有提供二维码生成记录保存的功能，主要是我平常工作中需要在多个二维码中来回切换，每次都要重新生成，非常麻烦。并且这些二维码其实是比较常用的，但是我又不想下载下来，我希望有个地方能维护着我的这个二维码，并且可以随时随地访问。\n所以我就开发了这个工具，可以生成二维码，并且可以保存二维码生成记录，并且可以随时随地访问。\n网站保存二维码的记录，不过因为目前没有接登录，所以二维码的记录是保存在浏览器的本地存储中的，所以如果浏览器清除缓存，那么二维码的记录就会消失。记录支持删除和二维码的下载\n网站名字 # 网站名字叫 QrCay，是因为我名字叫 Cayden，Qr 是二维码的缩写，所以网站名字就叫 QrCay。Cayden 有小岛的意思，寓意就是“二维码小岛”\n怎么实现的 # 我是通过Cursor AI 帮我实现的，我只需要告诉他我想要实现什么功能，他就会帮我实现，并且我还可以根据他的实现方式，进行修改，非常方便。不过一些网站的内容和细节的UI还是需要自己调整的\n生成二维码的技术主要使用的 qrcode.react 这个库，因为我使用的是react + vite 的组合，所以直接使用 npm 安装即可。\n网站的UI设计主要使用的 tailwindcss 这个库，这个库是基于 react 的，所以我在使用的时候，需要先安装 react，然后使用 react 的语法来实现。 目前这版样式还是比较简单的，后续会继续优化。\n网站支持多语言切换，主要面向的是国外的用户，但是中文用户也支持使用，不过可能打开会慢一些，因为网站是部署在 CF 上的，所以可能需要一些时间来加载。\n最后 # 这是个很简单的网站，刚上线没多久，整体还是比较粗糙的，后续会继续优化网站体验，并且会添加一些其他的功能，比如二维码的分享，二维码的下载，二维码的打印等等功能，欢迎大家使用，并且提出建议。\n","date":"2025年8月3日","externalUrl":null,"permalink":"/posts/vibe-coding-%E4%B8%80%E4%B8%AA%E4%BA%8C%E7%BB%B4%E7%A0%81%E7%94%9F%E6%88%90%E5%B7%A5%E5%85%B7/","section":"Posts","summary":"","title":"Vibe Coding 一个二维码生成工具","type":"posts"},{"content":"大家好，我是 Cayden，今年我又开始重拾独立开发了，继续走自己独立开发之路，之前也开发过时光里程表小程序，小程序每天大概有100-300左右的访问用户，虽然用户少，但是用户粘性还是挺大的，这么多年一直在运行着，也没怎么维护过了，还是有流量\n今年开始重新开了一个坑，网站名字叫万趣岛，听名字就能知道，这个网站一定是跟有趣相关的。\n网站介绍 # 这个网站主要用来分享有趣的独立网站、小游戏、工具以及AI相关应用，数据主要来自于自己的收集和用户投稿。目前已经上线3个月了，有上百个有趣的应用录入，每周都会有新的站点收录。网站的收录都是我一个一个的真实访问筛选和撰写介绍内容，当然也会用 AI 给我润色一下，总体还是比较浪费精力的\n不过好在，现在已经有很多用户通过搜索引擎访问到了，看到访问数据的增长还是很欣慰的，欢迎大家访问！\n为什么我要开发这个网站 # 虽然在做这个网站之前我已经看到有类似的产品了，但是我还是想维护一个自己独有的站点，因为不做这个事情，总感觉缺少点什么\n小的时候，父母订的报纸，我很喜欢报纸上的搞笑娱乐版面[幽默地带]，也就是一些梗图和奇趣图片，但也就当时乐呵乐呵，随后这个报纸就会被打包一起卖废品，我心想这么多有趣的素材不就可惜了，以后想看到也没有了。\n所以我就想把这些搞笑的报纸图片或者文字素材给剪下来，通过双面胶收集在了我的一个密码本里。我会把我的密码本分享给我的小玩伴，让他们也看看，非常享受这种分享“成果”的乐趣\n大学时期，因为自己学的计算机，关注一些UED设计和编程类的资讯，偶尔会看到一些炫酷的网站，每次看到就会把网站跟遇到宝一样收集起来，心想如果我要能做出这些创意网站就好了。后来大学毕业，开始做程序员的工作了，在日复一日的工作中，已经逐渐把自己的这些收集的爱好忘记了，对网站什么的已经提不起兴趣了\n在自己工作了多年的今天，我突然觉得，应该把这事情重新做起来，拥有一个自己的有趣网站，收集有趣和创意，然后分享出去，这是我想要做的事情\n网站的目标 # 网站会保持定期的更新，就像我的站名一样，目标是完成一万个有趣网站的收集，目前还差的很远。\n同时这个网站与其他同类型网站不同的是，我也会开发一些我自己的有趣小工具或者网页。\n因为我在收集有趣网站的时候发现，国内的有趣创意网站真的太少了，大多数都是国外的，对于国内的用户来说，第一由于墙的存在，需要科学上网，第二即使能够访问，网页上都是外语，并不是所有人的英语都很好，体验会大大折扣\n所以我会不定期分享一些我自己的创意小产品，放在我的网站万趣岛上，标签是万趣岛出品\n最后 # 欢迎大家常来我的网站万趣岛，也欢迎大家投稿，分享你的有趣小作品，愿这个世界充满乐趣与欢笑！\n","date":"2025年5月18日","externalUrl":null,"permalink":"/posts/%E4%B8%87%E8%B6%A3%E5%B2%9B%E4%B8%80%E4%B8%AA%E6%89%93%E5%B7%A5%E4%BA%BA%E5%BF%85%E5%A4%87%E7%9A%84%E6%91%B8%E9%B1%BC%E7%BD%91%E7%AB%99/","section":"Posts","summary":"","title":"万趣岛：一个打工人必备的摸鱼网站","type":"posts"},{"content":"","date":"2024年1月1日","externalUrl":null,"permalink":"/pages/","section":"Pages","summary":"","title":"Pages","type":"pages"},{"content":" 关于 CayDock # 欢迎来到 CayDock！这是我的个人产品导航网站，记录我在独立开发中遇到的挑战、经历和成长。\n关于我 # 我是 Cayden，一名专注于前端开发的独立开发者。我热爱技术分享，喜欢记录成长路上的点点滴滴。\n这个网站 # CayDock 不仅仅是一个博客，更是我技术成长的见证。在这里，你可以找到：\n前端开发相关的技术文章 独立开发的经验分享 技术选型和架构思考 个人成长和职业发展心得 联系我 # 如果你有任何问题或建议，欢迎通过以下方式联系我：\n邮箱：cayden@caydock.com GitHub：@cayden 感谢你的访问！\n","date":"2024年1月1日","externalUrl":null,"permalink":"/pages/about/","section":"Pages","summary":"","title":"关于","type":"pages"},{"content":" 问题记录 # 背景：通过 Jest 和 React Testing Library 对 React Native 做自动化测试 问题： 代码中出现 AppState 的使用\nimport { AppState } from \u0026#39;react-native\u0026#39;; AppState.removeEventListener(\u0026#39;change\u0026#39;, handleAppStateChange); 报错：TypeError: import_react_native.AppState.removeEventListener is not a function\njest.config.js 配置使用了 React Native 预设\nmodule.exports = { preset: \u0026#39;react-native\u0026#39;, ... 经过排查发现是因为 React Native 提供的 jest mock 文件缺失部分方法\n路径：*/react-native/jest/setup.js\n.mock(\u0026#39;react-native/Libraries/AppState/AppState\u0026#39;, () =\u0026gt; ({ addEventListener: jest.fn(() =\u0026gt; ({ remove: jest.fn(), })), })) 解决方案： # 项目临时方案是将 packages/react-native/jest/setup.js 拷贝下来，增加 react-native/Libraries/AppState/AppState 模块的 removeEventListener 和 currentState方法的mock\n.mock(\u0026#39;react-native/Libraries/AppState/AppState\u0026#39;, () =\u0026gt; ({ addEventListener: jest.fn(() =\u0026gt; ({ remove: jest.fn(), })), removeEventListener: jest.fn(), currentState: jest.fn(), })) 然后放在项目仓库中在 jest.setup.js 文件头部引入\n或者在 jest.config.js 的 setupFilesAfterEnv 入口引入\n最后，这个缺陷我已经给 React Native 官方仓库提了Pull Request，已经合并主分支了\n","date":"2023年9月23日","externalUrl":null,"permalink":"/posts/jest-mock-appstate-typeerror-import-react-native-appstate-removeeventlistener-is-not-a-function/","section":"Posts","summary":"","title":"\u003e-","type":"posts"},{"content":"爱家派：感恩环境，环境获利者，我的一切都是这个家给的\n恨家派：批判环境，环境受害者，我的一切不幸都是这个家带来的\n无家派：无视环境，环境不重要，我的一切得到都在在于自己的实力，甚至多个家庭资源为我所用\n","date":"2023年8月19日","externalUrl":null,"permalink":"/posts/%E5%AF%B9%E4%BA%8E%E5%AE%B6%E7%9A%84%E6%80%81%E5%BA%A6/","section":"Posts","summary":"","title":"对于家的态度","type":"posts"},{"content":"程序员要想做点副业，千万不要做外包项目，更不要做那些不入流的事，一定要做那种有积累有沉淀的东西，无论是写代码，做咨询，还是做写文章等，一定一定要系统化！你每天都在为你的城堡加一块砖，只有这样才能成为资产。另外，强烈建议工匠的方式做事，因为只有这样，“基础”和“副产品”才会变得可观……\n软件方面，我非常建议做多人协作的订阅制产品，因为用户的沉默成本更大。同时，我也非常推荐能够在某成功建康商化业的PaaS/SaaS 的 Marketplace生态里做add-ons或增强，这就是所谓的“小而美”的事，另外，最好能做全球化英文版的，因为，开放和自由从来都是商业化的温床，通过开源或社区建团队最佳……\n个人方面，要学会放大自己的价值，高级人才在35岁后的价值不在大公司里，而是中小型在高速成长求贤若可的公司，看看这些后浪公司要解决什么样的问题，再观察一下前浪的关键技术，你就知道你要什么样的技能了……然后，你要思考的是低成本性价比高的解决方案，大多时候，低成本方案会成为最终的胜者……\n","date":"2023年8月19日","externalUrl":null,"permalink":"/posts/%E7%A8%8B%E5%BA%8F%E5%91%98%E4%B8%AA%E4%BA%BA%E5%8F%91%E5%B1%95/","section":"Posts","summary":"","title":"程序员个人发展","type":"posts"},{"content":" 输入 # 书籍 + RSS + Weibo + 推特\n沉淀 # 书籍 + 文章\n保存在ibooks 导出 klib\nRSS + Weibo + 推特 摘录保存在记事本\n输出 # 定时清理笔记 =\u0026gt; 输出文章\n","date":"2023年8月19日","externalUrl":null,"permalink":"/posts/%E7%9F%A5%E8%AF%86%E4%BF%A1%E6%81%AF%E6%B5%81/","section":"Posts","summary":"","title":"知识信息流","type":"posts"},{"content":"解开这个谜的关键是把问题换一种提法。为什么聪明的小孩没有让自己变得受欢迎？如果他们真的很聪明，为什么找不到受欢迎的诀窍呢？他们在标准化测试中表现得这么好，为什么就不能在这方面也大获成功呢？\n虽然“书呆子”饱尝不受欢迎之苦，但是为了解除痛苦而让他们放弃“聪明”，我想大多数人是不会愿意的。对他们来说，平庸的智力是不可忍受的。不过，要是换了别的孩子，情况就不一样了，大多数人会接受这笔交易。对于很多人来说，这反而是更上一层楼的机会。即使是那些智力排名在前20%的学生（我在这里假设智力可以测量，那时的人们似乎都相信这一点），谁不愿意用30分的成绩换来别人的友爱和钦佩？\n黑客与画家的共同之处，在于他们都是创作者。与作曲家、建筑师、作家一样，黑客和画家都是试图创作出优秀的作品。他们本质上都不是在做研究，虽然在创作过程中，他们可能会发现一些新技术（那样当然更好）。\n创造优美事物的方式往往不是从头做起，而是在现有成果的基础上做一些小小的调整，或者将已有的观点用比较新的方式组合起来。这种类型的工作很难用研究性的论文表达。\n黑客真正想做的是设计优美的软件，考核这种工作是非常困难的。你本人需要有良好的设计感，才能去考核别人的设计是否良好。但是，你觉得你有“良好的设计感”，与你实际是否具有，不存在相关关系，甚至可能存在负相关。能够考核的东西往往都是很无趣的，并不能给世界带来惊喜\n唯一有效的外部考核就是时间\n我认识的黑客，没有一个人喜欢用静态类型语言编程。我们需要的是一种可以随意涂抹、擦擦改改的语言，我们不想正襟危坐，把一个盛满各种变量类型的茶杯，小心翼翼放在自己的膝盖上，为了与一丝不苟的编译器大婶交谈，努力地挑选词语，确保变量类型匹配，好让自己显得礼貌又周到。\n单人创作和多人合作是不一样的，单人创造就像拿着铅笔涂涂改改，这种情况适合松散类型的语言，随时进行改造重构。但是涉及到多人合作，这个时候就需要大家商量协议接口类型等契约，目的也是为了提高整体的效率和质量\n大学和实验室强迫黑客成为科学家，企业强迫黑客成为工程师。\n发现在他们看来，“黑客”的工作就是用软件实现某个功能，而不是设计软件。在那里，程序员被当作技工，职责就是将产品经理的“构想”（如果这个词是这么用的话）\n开源运动最鲜为人知的优点之一，就是使得学习编程变得更容易了\n程序写出来是给人看的，附带能在机器上运行。\n翻开老照片，看到以前的样子，你会不会感到难为情？我当时真的是穿成这样吗？是的，你没看错，你就是穿成这样。我们穿衣服的时候，根本不知道自己看上去有多傻，还以为很时尚。\n硅谷出现在美国，而不是出现在法国、德国、英国、日本，这绝非偶然。后面那些国家的人们总是按部就班地行事。\n对于适当的不服从管教，保持宽容不会有太大的坏处，反而很有利于美国的国家优势，它使得美国不仅能吸引聪明人，还能吸引那些很自负的人。\n公民自由真的是国家富强的原因，而不是结果吗？我认为是的。在我看来，一个人们拥有言论自由和行动自由的社会，往往最有可能采纳最优方案，而不是采纳最有权势的人提出的方案。专制国家会变成腐败国家，腐败国家会变成贫穷国家，贫穷国家会变成弱小国家。经济学里有一条拉弗曲线（Laffer curve），认为随着税率的上升，税收收入会先增加后减少。我认为政府的力量也是如此，随着对公民自由的限制不断上升，政府的力量会先增加后减小^。至少现在看来，我们的政府很可能蠢到会真的把这个实验付诸实施，亲自验证一下这个观点。但是，税率提高了还能再降下来，而一旦这个实验铸成大错，就悔之晚矣，因为极权主义制度只要形成了，就很难废除。\n现在，升级不再对用户形成大的冲击。久而久之，软件变得更强大了。这需要开发者付出一定的努力。他们必须正确地设计软件，使得它能够平滑升级，不让使用者感到困惑。这就是互联网软件面临的新问题，不过解决办法是有的。 所有用户都使用同样版本的互联网软件，bug一发现就会立刻得到纠正。所以，它的bug应该比桌面软件少得多。在Viaweb，我记得未解决的bug最多一次也总共只有十个，大部分问题都是一发现就得到了解决，不会遗留下来。这要比pc互联网时代已经从客户端应用到网页应用过度 移动互联网时代感觉现在还是app的世界\n复合式bug有一个子类型：两个bug是互相弥补的，好比“负负得正”，软件反而能正常运行。这种bug可能才是最难发现的bug。当你修正了其中的一个bug，另一个bug才会暴露出来。这时对你来说，你会觉得刚才修正错了，因为那是你最后修改的地方，你就怀疑自己在那里做错了，但是你其实是对的。」\n事实上，因为bug不多，你只有经过一些复杂的过程以后才会遇到它们，所以高级使用者往往因为发现了bug感到很得意。他们打电话给客服时，多半是一副胜利者的口吻，而不是怒气冲冲的样子，好像他们击败我们得分了一样。\n^「《人月神话》（The Mythical Man-Month）是布鲁克斯（Frederick Brooks）所写的一本软件项目管理名著。所谓“人月”就是一个人在一个月内所能完成的工作量。假如某个项目预估需要12个人月，那么派4个人处理这个项目，理论上需要3个月，派6个人则只需要2个月。但是，布鲁克斯认为这种换算机制在软件业行不通，是一个神话，因为软件项目是交互关系复杂的工作，需要大量的沟通成本，人力的增加会使沟通成本急剧上升，反而无法达到缩短工期的目的。在本质上，软件项目的人力与工期是无法互换的，当项目进度落后时，光靠增加人力到该项目中，并不会加快进度，反而有可能使进度更加延后。（该书英文版已由人民邮电出版社出版。）——译者注」\n人数越来越多，开会讨论各个部分如何协同工作所需的时间越来越长，无法预见的互相影响越多越大，产生的bug也越多越多。幸运的是，这个过程的逆向也成立：人数越来越少，软件开发的效率将指数式增长。\n^「基准测试（benchmark test）指的是先设置一个基本的数据环境，测试应用程序的表现，然后把这个表现当作“基准”（benchmark），用来比较其他情况下应用程序的表现。——译者注」\n没有盗版是一种“优势”，但也是一个问题。一定数量的盗版对软件公司是有好处的。不管你的软件定价多少，有些用户永远都不会购买。如果这样的用户使用盗版，你并没有任何损失。事实上，你反而赚到了，因为你的软件现在多了一个用户，市场影响力就更大了一些，而这个用户可能毕业以后就会出钱购买你的软件。\nViaweb一开始就把个人和小企业当作目标客户。我认为这是互联网软件的通行规则。这些客户决策比较灵活，又需要低成本的新技术，所以他们更愿意尝试新事物。\n网页刚诞生的时候，也不是为了用作应用程序的界面，它只是刚好能满足需要。对于相当一部分使用者来说，打开浏览器就能使用软件本身，这已足够吸引人了，用户操作界面的丑陋和不方便并不是一个严重的问题\n几个黑客搞懂如何租用办公室，或者如何雇用销售人员，要比那些公司（不管大公司还是小公司）搞懂如何正确写出软件容易得多\n如果你想赚100万美元，就不得不忍受相当于100万美元的痛苦\n如果创业那么轻松，那么所有人就都去创业了。\n通过创造有价值的东西而致富，这种方法的优势不仅仅在于它是合法的（许多其他方法如今都是不合法的），还在于它更简单。你只需要做出别人需要的东西就可以了。\n财富才是你的目标，金钱不是这里没必要把金钱和财富区分开。金钱是兑换财富的最便捷的方式，钱的本质是调动资源的能力，在一个正常的市场环境中，有钱你就是拥有财富\n目前还存在的最大的手工艺人群体就是程序员。\n工作就是在一个组织中，与许多人共同合作，做出某种人们需要的东西。\nCEO、电影明星、基金经理、运动员的头顶都悬着一把宝剑，随时可能掉下来。一旦他们搞砸了，他们就完了。\n大公司就像巨型的古罗马战舰，一千个划船手共同划桨，推动它前进。但是，两个因素使得它快不起来。一个因素是，每个划船手看不到自己更努力划桨有何不同；另一个因素是，一千人的团队使得任何个人的努力都被大大地平均化了\n理想情况下，你与其他愿意更努力工作的人一起组成一个团队，共同谋取更高的回报（相比他们为大公司工作的情况）。因为创业公司的团队往往是自发形成的，许多有抱负的创始人彼此之间早就相识（至少听说过对方），所以他们对彼此贡献的评估要比一般的小团体更准确。创业公司不仅仅是十个人的团队，而且是十个同类人的团队。\n团队越大，每个人的贡献就越接近于整体的平均值\n创业公司就像游击队一样，喜欢选择不易生存的深山老林作为根据地，政府的正规军无法追到那种地方\n真正创业以后，你的竞争对手决定了你到底要有多辛苦，而他们做出的决定都是一样的：你能吃多少苦，我们就能吃多少苦。\n创业的付出与回报虽然总体上是成比例的，但是在个体上是不成比例的\n蚊子唯一的防御就是，作为一个物种，它们的数量极多，但是作为个体，却极难生存。 创业公司如同蚊子，往往只有两种结局，要么赢得一切，要么彻底消失。你通常不知道自己会是哪一个结局，只有等到最后一刻才会明了。\n你必须时刻牢记的最基本的原则就是，创造人们需要的东西，也就是创造财富\n缓慢工作的后果并不仅仅是延迟了技术革新，而且很可能会扼杀技术革新。只有在快速获得巨大利益的激励下，你才会去挑战那些困难的问题，否则你根本不愿意去碰它们\n冷战、第二次世界大战、近代的大多数战争都说明了这个道理。要鼓励大家去创业。只要懂得藏富于民，国家就会变得强大。让书呆子保住他们的血汗钱，你就会无敌于天下。\n每个人的技能不同，导致收入不同，这才是贫富分化的主要原因\n一个人的工作具有多少价值不是由政府决定的，而是由市场决定的。\n当我们说一些工作报酬过高，另一些工作报酬过低，我们的真实想法到底是什么？在自由竞争的市场经济中，价格由买家的需求决定。如果人们喜欢棒球甚于喜欢诗歌，那么棒球运动员的收入就是要比诗人的收入高。如果说某种工作的报酬过低，那就相当于说人们的需求不正确。当然，人们确实会需求不正确的东西。这有什么好奇怪的呢？你不觉得声称某种工作报酬过低的说法更奇怪吗^？如果你觉得由于人们的需求不正确，导致某些工作的报酬过低而且不公平，那么这个世界一定会让你感到非常遗憾，人们就是喜欢看电视真人秀，而不是莎士比亚作品，人们就是喜欢吃玉米热狗，而不是水煮蔬菜，这是不是很不公平呀？要是你觉得不公平的话，那你就同把蓝颜色说成最漂亮的颜色、把方的说成圆的那样蛮不讲理。就好像微博上经常讨论的明星和科学家的收入问题，明星的收入远大于科学家，但是这能有什么办法呢，需求和市场决定一切\n当我们讨论“收入分配不公平”时，我们还要问问收入从何而来，收入背后的财富到底是谁生产出来的^。如果收入完全根据个人创造的财富数量而分配，那么结果可能是不平均的，但是很难说是不公平的。公平与平均截然不同，平均主义会滋生懒惰\n很多人对贫富分化不满意的第二个原因就是，在大部分的人类历史中，积累财富最常见的方法其实是偷窃。游牧社会是偷别人的牲口，农业社会是征税（和平时期）和直接掠夺（战争时期）\n富人日常做的事情也和普通人差不多。无所事事的闲适生活早就成为罕见情况了。如今，确实有很多人非常有钱，完全不必再去工作，他们之所以还在工作，不是因为感到社会压力，而是因为无所事事使人感到孤独和消沉\n技术在加大收入差距的同时，缩小了大部分的其他差距\n总的来说，你要避免的是绝对贫穷，而不是相对贫穷促进个人致富，消灭绝对贫困，容许社会贫富差距，但是不能太大 共同富裕不是平均富裕\n","date":"2023年8月19日","externalUrl":null,"permalink":"/posts/%E9%BB%91%E5%AE%A2%E4%B8%8E%E7%94%BB%E5%AE%B6/","section":"Posts","summary":"","title":"《黑客与画家》文摘","type":"posts"},{"content":"对计算机科学的掌握程度，决定了一个计算机行业从业者能走多远。\n吴军博士在《浪潮之巅（第四版）》对工程师做了五个级别的划分：\n一级：能够开创一个产业。历史上有爱迪生、特斯拉、福特等人。\n二级：能设计和实现别人不能做出的产品。比如实现第一台实用化个人电脑的沃兹尼亚克、iPhone 和 Google Glass 的总设计师。\n三级：能独立设计和实现产品，并且在市场上获得成功。\n四级：能指导和带领其他人一同完成更有影响的工作。\n五级：能够独立解决问题，完成工程工作。\n","date":"2023年8月19日","externalUrl":null,"permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%B7%A5%E7%A8%8B%E5%B8%88%E4%BA%94%E7%BA%A7/","section":"Posts","summary":"","title":"计算机科学工程师五级","type":"posts"},{"content":" 价值 # 一、完成业务需求工作 # 这是作为一个公司员工或者是前端的基础任务\n二、研发效率 # 支撑业务高速迭代，技术选型、工具链、文档建设、组件沉淀、自动化、基础服务等\n三、研发质量 # 高可用、高性能、用户体验卓越，流程规范、监控、code-review、局部重构、故障反思与改进、团队学习与进步等\n学习步骤 # 一、打牢基础，深度学习 # 基础是内功，内功决定一个程序员的天花板\n二、做好项目，积累经验 # 积累经验，研究新技术，新模式，练好招式\n三、经验输出，积极交流 # 展示自己的总结，结交好友，寻找伯乐\n","date":"2022年3月25日","externalUrl":null,"permalink":"/posts/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%9A%84%E4%BB%B7%E5%80%BC%E4%B8%8E%E5%AD%A6%E4%B9%A0%E6%AD%A5%E9%AA%A4/","section":"Posts","summary":"","title":"前端工程师的价值与学习步骤","type":"posts"},{"content":" 2019年3月拍摄于扬州瘦西湖\n为什么你要当一名摄影家？ # 不久的将来，也许有人会问你：\n“为什么你要当一名摄影家？”\n你将这样回答：\n“我要成为一名摄影家它使我融入周围的世界。”\n“我要成为一名摄露家器为它使我得到心灵的甘露和餐桌上的面包。”\n“我要成为一名摄影家，因为它使我有能力洞察世间万象并记录下人类的伟大进程。”\n怎样才是一张好照片？ # 一幅好照片只集中在以下三条基本原则上：\n1.一幅好照片要有一个鲜明的主题（有时也称之为主体）。或是表现一个人，或是表现一件事物，甚至可以表现该题材的二个故事情节。主题必须明确，毫不含糊，使任何观赏者一眼就能看得出来。\n2.一幅好照片必须能把注意力引向被摄主体，换句话说，使观货者的目光一下子就投向被摄主体。\n3.一幅好照片必须画面简洁，只包括那些有利于把视线引向被摄主体的内容，而排除或压缩那些可能分散注意力的内容。\n** 现在，要是你再去拍照时，就该向自己提出两个问题了：**\n第一，这张照片我要表现的主题是什么？\n第二，我怎样把注意力集中到被摄主体上，又如何把观赏者的视线吸引过来?\n如何寻找拍摄素材？ # 观察你周围的世界。 一个日本旅游者在参观你的家乡时也会发现成千上万个动人的画面。\n他之所以能在你的世界里“看到”那么多画面，是因为你的世界对他来说是新奇的\n他观察时使用的是完全不同的眼光。所以，你也应该一样，必须用全新的方式重新观察你周围的一切。\n以上摘自《美国纽约摄影学院摄影教材》\n","date":"2022年3月19日","externalUrl":null,"permalink":"/posts/%E5%AD%A6%E5%A5%BD%E6%91%84%E5%BD%B1%E7%9A%84%E7%81%B5%E9%AD%82%E4%B8%89%E9%97%AE/","section":"Posts","summary":"","title":"学好摄影的灵魂三问","type":"posts"},{"content":" RSS（英文全称：RDF Site Summary 或Really Simple Syndication），中文译作简易资讯聚合，也称聚合内容，是一种讯息来源格式规范，用以聚合多个网站更新的内容并自动通知网站订阅者。使用RSS 后，网站订阅者便无需再手动检视网站是否有新的内容，同时RSS 可将多个网站更新的内容进行整合，以摘要的形式呈现，有助于订阅者快速获取重要资讯，并选择性地点阅检视。 \u0026ndash; 维基百科 https://zh.wikipedia.org/wiki/RSS\n为什么又开始使用RSS订阅了 # 在使用了大约十年的微博又换了头条之后，我最终还是把获取信息的工具换成了RSS\n微博的 slogan 是 “随时随地发现新鲜事”，它的优势是获取信息非常及时，也是舆论爆发的主要场地。不过它的劣势也非常明显，信息鱼龙混杂，评论戾气很重，对立言论让人感觉摸不着头脑，整个评论区就是个罗生门\n后来，感觉微博实在没什么可看的，特别是热搜无聊到明星一举一动都要上个热搜，于是我就把微博卸载换成了今日头条\n头条的特点是根据你的喜好推荐你想看的内容，这样其实有利有弊，好处是不需要你去浪费时间筛选想看的内容，坏处是这样的推荐算法让会你完全成为了信息的井底之蛙。在头条关注了一些财经博主和新闻媒体，刷了一段时间的，发现头条的资讯内容大部分都是比较肤浅的快讯，没有很多深度的内容。或者说我的关注方式不对吧，总之信息很多，但都不想停留太久\nRSS 在工作的几年断断续续用了很长时间，但是最后基本都是因为工具不好用放弃过一段时间，比如被墙或体验不好或功能太复杂。22年开年，权衡利弊，感觉还是 RSS 更适合我，最主要的是可以订阅一些技术周刊或者博客，之前漫无目的看头条和微博导致我对技术关注少了很多，已经跟不上社区的步伐了，感觉还是非常可惜的\n虽然现在RSS订阅已经算是一个“老古董”了，很多网站或者博客已经停止服务了，但是还是有少数内容不错的网站依然提供服务，依然可以组合订阅出很好的信息流，所以 2022 年初，决定重新开始使用 RSS\n我的 RSS 使用姿势 # 订阅工具 # 之前在逛社区时，无意中发现了 NetNewsWire，一款开源的 RSS 订阅客户端，安装包很小，不过目前主要支持苹果生态的设备，使用了一段时间总体感觉还是很满意的，UI看起来比较清爽，基本功能该有的都有（如头图所示）\n在使用 NetNewsWire 之前也用过 Feedly、Inoreader、 深蓝阅读 甚至最早QQ邮箱的订阅，不过现在基本已经被强了，其他的也因为用户体验不好弃用了\n订阅资源 # 目前关注的内容主要是国内几个科技财经技术相关的站点和新闻网站，比如虎嗅、雪球、InfoQ 和澎湃\n其他还有一些社区的内容，比如知乎、github趋势、推特、V2EX\n还有几个个人博主和技术周刊，我把更新频率较慢的放在一起，怕被频率高信息源的直接淹没了，例如阮一峰的网络日志、奇舞周刊、酷壳、MacTalk等博客\n视频类的我也有订阅，主要是油管的一些频道，令人高兴的事是油管频道链接直接支持订阅，非常nice!\n现如今（2022年）已经有很多网站不提供RSS 订阅了，不过有个开源项目 Rsshub 可以支持很多站点的抓取，并生成 feed 可以订阅，资源非常丰富并且一直在更新中**(2022年3月订阅源已被强，不过可以自己部署或者找镜像)**\n还有可以转微信公众号的 feed 聚合站点：今天看点啥、Werss, 不过都有免费订阅数量限制，更多需要买会员了\n使用感受 # 通过 NetNewsWire 订阅了以上列举的一些资源之后，每天会在空余时间浏览一下，资讯类订阅的信息更新非常及时的，最喜欢的就是虎嗅的订阅，会推荐很多深度文章和精选的微信公众号文章，总体感觉质量还是非常不错的，能学到平常很难接触到的知识，比如今天读到的《SpaceX星际飞船安全着陆，但载人登陆火星依然漫长》- 中国工程院院刊© ，我在头条或者微博应该不会主动订阅这种工程院的文章，但是通过订阅资讯类站点，经过编辑的精选我就能了解更多的知识，不会出现信息面的闭塞\n虽然去找订阅资源和订阅的过程比较繁琐，但这样操作下来的结果就是，得到一个适合自己的信息流系统，能更高效的获取信息。RSS本质来讲是反人性的，但是往往反人性的东西会带来充实\n自我感觉深度文章的价值还是高于简讯类的信息，所以在订阅源的挑选上，我会优先订阅深度文章类型的，快讯类的就会被我剔除。其实这个世界很多信息根本不需要知道，少一点纷杂的信息，内心可以多一些平静，逃离无限的 refresh 过程。引用一篇文章下面的评论，感觉说的很对：\n使用聚合资讯订阅就是为了有一个属于自己、可以离线阅读的聚合信息源。 要达到数字极简的目标，就需要避免受到各种在线推送算法、碎片化通知的干扰\nRSS 的发展 # RSS 虽然非常好用，但是还是有很多缺陷导致了他的落寞，注定小众。\n比如最重要的商业化，RSS 只是个简单资源订阅协议，无法直接让内容提供方实现盈利，也就让生产者缺少了开放 RSS 的动力\n因此，内容源的缺乏也导致用户在寻找订阅源的过程中非常繁琐，劝退了很多人，我曾经也因这个原因放弃过。不过，随着 Rsshub 的壮大，目前RSS 有了一点复兴的意思，毕竟内容源的丰富程度是很关键的，决定了 RSS 的用户体验\n总之，RSS 要想发展壮大还是要在商业化上进行探索，只有保障了内容提供方的利益，才能让内容方更愿意提供 feed 内容的持续输出\n最近出现了基于大区块链概念的RSS3协议 rss3.io，对订阅的内容增加了所有权的概念，甚至可以通过区块链对参与者进行利益的分配，这个激励机制的加入可能会促进 RSS3 应用的发展。目前来看（202202）还只是在概念阶段，甚至有炒作的情况，具体发展还是静观其变吧\n看了下自己的手机，希望互联网能真正的回归到互联网的初衷吧\n","date":"2022年2月19日","externalUrl":null,"permalink":"/posts/rss%E8%AE%A2%E9%98%85%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97%E5%88%86%E4%BA%AB/","section":"Posts","summary":"","title":"RSS订阅使用心得分享","type":"posts"},{"content":" 总体回顾 # 2021 这一年过的也是很快，一整年都在疫情的笼罩下，总感觉心里不畅快。\n今年算是过的比较“浑浑噩噩”的一年，没有什么目标，没有什么可以拼的方向，处在一个比较迷茫的时候。另一方面人也相对放松不少，有时间思考一些事情。同时这一年也去过一些地方，读过一些书，也有一些感悟\n去过的地方 # 今年虽然有疫情但是还是实现了三次长途旅行，分别去了青岛、西安和甘南（甘肃的南部地区）\n青岛 # 2020年的年底买了东航随心飞，只有半年的有效期，基本都用在回郑州了找女朋友了。第一次用在出去玩就是四月份去了趟青岛\n沿着海岸线散步，海天一色的美景，很治愈\n看到有人在海边坐在野餐垫上看书，感觉很惬意啊\n在小麦岛拍的夕阳，附近有很多年轻的学生周末野餐\n奥林匹克帆船中心，还是很美的\n奥帆中心里面的小店门口立着 “我爱青岛” 标识\n青岛给人的感觉是个很浪漫的城市，工作日在城区上上班，周末来海边走走，放松放松可太惬意了。不过听说青岛冬天比较冷，而且湿气重，没体验过就不评论了\n西安 # 西安是我跟女朋友五一劳动节一起去的，因为我们异地，平常也没有太多时间一起出去，就选择这个假期出去玩，但是就像预期的那样，人很多，第一天去，还下了场大雨\n西安鼓楼\n西安的回民街，去吃了 biangbiang 面，味道还是很好的，但是稍稍有些油了\n大雁塔附近，也是人山人海的，本来想看演出，结果因为疫情原因暂停了，非常可惜\n大唐不夜城，也是人太多也没看到什么表演，匆匆走过去了\n总之，西安这趟行程体验一般，时间选择的不太好，下次有机会再来吧。出去玩还是尽量不选择节假日吧，花销很高反而体验不好\n甘南 # 甘南是6月份跟公司团建一起去的，之前去过川西但是没有去过这里，感觉是今年最佳的旅行，因为真的是太美了，但是因为甘南海拔有些高，有些高反的症状\n刚到兰州就找地方吃饭，当然是要吃当地的烤羊肉串啦\n来到拉卜楞寺附近的民俗住下，我们团队包下了整个两层楼，大家晚上一起聊天玩游戏，相当热闹\n自驾走在道路上，看着沿途路上的风景，车里放着音乐\n碌曲县路上的一个观景台，入口就有卖牛肉干的，我们买了好多回去，砍价砍了半天\n站在扎尕那民宿拍的，感觉美的不行，仿佛到了瑞士一样。顺便说一句，中国的西部还是有很多好看的大自然风光的，不比欧洲或者其他国家的景色差，只是没有开发或者宣传的比较少而已\n花湖生态区，之前从来没听说过这个景区，但是真的很美，真的就像进入画中一样，我们在这里拍了好多张照片\n黄河九曲第一弯，我们是坐一个超长的扶梯上来的，美景尽收眼底，这里的黄河真的很平静很壮观\n总之甘南是个好地方，17年就有同事推荐过，当时没机会去。这里非常原生态，是城市忙碌打工人出来放松的圣地，并且人也不多。以后会带自己女朋友来看看。\n看过的书 # 2021年闲暇之余没什么特别要做的事情，周末之余看了些杂书\n《在火星上退休——伊隆•马斯克传》 # 一本讲马斯克的家庭背景和创办科技公司的心路历程，以及他的未来理想。看完全书，看到马斯克的成功并非偶然，冒险，永不言败，创新，真诚，目标，努力，圈子，家庭背景，聪明等等一系列因素促使了他的成功。\n“事实上，唯一有意义去做的事，就是努力提高全人类的智慧，为更高层次的集体文明而努力一生，这就是我活着的意义。”\n《向上生长》 # 九边大佬的一本讲人生问题的书，有用的东西很多，但是需要慢慢去消化才行。读完之后感觉能记住的不多。不过有很多话我还是很有共鸣的。后来在微博和头条都关注了，文章质量很高，还是挺佩服的\n《我们仨》 # 这本书是讲杨绛先生一家人的生活的书，虽然一开始读起来有些感觉不知所云，到后面越读越感兴趣，一口气看完了。背景是上个世纪纷杂混乱的年代，从微观角度叙述了一家三口的分分合合，很温馨，也很耐人寻味。\n《让时间陪你慢慢变富》 # 李笑来的一本讲定投的书，看过之后总之就是一个结论：不论是微观的金融还是宏观的人生，我们看不清趋势，所以我们能做的就是去定投。定投在这里不仅仅是股市基金一类的投资产品，还包括我们的人生，持续不断的学习也是定投。定投是“主动地被动”的最佳践行策略\n《元宇宙》 # 一本追热度的一本书，作者写的很快，我看的也比较快。基本上就是了解下什么是元宇宙。\n元宇宙八个基本特征：身份（ Identity）、朋友（ Friends）、沉浸感（ Immersive）、低延迟（ Low Friction）、多元化（ Variety）、随地（ Anywhere）、经济系统（ Economy）和文明（ Civility）。基于 Baszucki的标准，“元宇宙” =创造 +娱乐 +展示 +社交 +交易，人们在“元宇宙”中可以实现深度体验。\n《解读基金——我的投资观与实践（修订版）》 # 今年买了些基金，对基金的投资总感觉是一知半解，想找本书系统性的学习下，这本书作者写的时候比较早了，但是基金的基本知识是不会变的，所以还是有参考价值的\n按照风险调整后的收益对同类的基金进行排序，收益最高的排在前列。排在前 10%的基金被授予五星基金，其后 22. 5%的基金被授予四星基金，再后面 35%的基金被授予三星，再再后面的 22. 5%是两星基金，最后的 10%是一星基金。\n投资基金是理财，而不是发财。\n长期来讲市场是向上的，我们赚的是投资企业的钱\n投资观念：我会反复强调风险和长期投资。风险是必然的，也只有长期投资才能降低这些风险。预测市场绝对不是好主意\n工作与学习 # 工作上 2021 年一直感觉自己很忙，加班的日子还是很多的，总体感觉这一年就是 Focus 在公司业务上，对技术的关注度降低很多。这也是我最近在思考的问题：未来的技术成长方向到底是是什么？这也是2021年对技术迷茫的表现。可能自己已经到了瓶颈期了，感觉对什么技术都提不起兴趣了，觉得没有什么可钻研的了，也可能是我沉迷工作，太久没关注社区技术的更新了，导致已经失去了追技术的热情了\n总之 2022 年还是要调整下自己的心态。寻找新的钻研方向。争取能输出一些东西\n除了技术，英语的学习也是在逐步进行中，买了新概念三来复习和稳固自己的英语听读。虽然学习进度有点慢，但是还是希望自己能坚持下来\n最后 # 以上就是我的2021年总结，本来感觉2021年过的还是比较平庸的，但是感觉这一年说快不快，说慢也不慢。去过一些地方，看过一些书，总体还是比较充实的一年吧\n以上\n","date":"2022年1月23日","externalUrl":null,"permalink":"/posts/%E6%88%91%E7%9A%842021%E5%B9%B4%E7%BB%88%E5%9B%9E%E9%A1%BE%E4%B8%8E%E6%80%9D%E8%80%83/","section":"Posts","summary":"","title":"2021年回顾与思考","type":"posts"},{"content":" 群名大全小程序，提供最具逼格趣味的微信群名，带你装逼带你飞，也欢迎分享你的霸气群名，微信搜索『群名大全』或 扫描小程序码访问\n","date":"2020年10月11日","externalUrl":null,"permalink":"/posts/%E7%BE%A4%E5%90%8D%E5%A4%A7%E5%85%A8%E5%B0%8F%E7%A8%8B%E5%BA%8F/","section":"Posts","summary":"","title":"群名大全小程序","type":"posts"},{"content":" 时光里程表是一款可以记录重要日子的小程序。包括倒数日、正数日、纪念日、生日、恋爱天数等，同时支持年、月、周、日多维度切换。微信搜索『时光里程表』或 扫描小程序码访问\n","date":"2020年6月23日","externalUrl":null,"permalink":"/posts/%E6%97%B6%E5%85%89%E9%87%8C%E7%A8%8B%E8%A1%A8%E5%B0%8F%E7%A8%8B%E5%BA%8F/","section":"Posts","summary":"","title":"时光里程表小程序","type":"posts"},{"content":" “命”主要取决于两个因素：环境因素和我们自己对未来走向划定的方向\n幸福感：需求（欲望）得到满足时所产生的愉悦感\n本源：基因的传承和影响力 需求 精神层面：成就感、情感、安全感、舒适感、娱乐 生理层面：性、吃、睡 人生是一条河，每个人总希望自己这条河能够更宽一点，更深一点，更长一点\n我们必须承认，任何社会都是分层次的\n对于年轻人来讲，对自己的投资和职业上的进步，远比在股市上捞点钱或者向父母借钱买一套房子更为重要，也更为靠得住\n亲密关系重要程度：夫妻优于子女，更优于双方父母\n向死而生，周国平对待生活的态度：“这个世界大家其实都在排着队沿着一条路往前走，停不下来，走到尽头就是死亡（到此为止和梁实秋讲得差不多)。这时，有些男人和女人搭上了腔，开始说笑起来，更多的人参与了进来，整个队伍便充满了欢乐。”\n参考《自私的基因》，我们不过是基因的载体，所有的物质的生命，不过是基因为了延续和进化的目的而存在的，我们的生命真的没有那么重要。在我们有限的生命中，如果能够将遗传的信息传递下去，再将创造出的信息（知识等）流传下去，我们的生命已经相当完美。\n很多时候，我们把太多的精力花在了选择上，而不是经营上，导致难以精进。或许少些选择，会更加聚焦，也会让我们更幸福、更成功。\n生命有限，少做事情，做好事情\n长远利益大于眼前利益，人生要做动态规划\n大部分人都在忙忙碌碌中匆匆地走完一生，是否有幸福可言，只有天晓得\n阅读不仅让我们在冷酷无情的科技时代获得喘息，而且重启了大脑深入思考的功能，还是抵抗狭隘、思想控制和舆论支配的方式\n朋友是我们一生的财富\n互联网的本质是连接，连接比拥有更重要\n当一个公司的历史使命完成之后，它退出历史舞台是对整个社会的最后一次贡献，因为它把宝贵的人力和土地资源释放给了未来的公司\n最好的教育是让受教育者自己发挥特长和潜力\n人的第一份工作很重要，它的性质和成败决定了你此后职业发展的方向和事业起点\n永远要明确，工作不是为了公司或者他人，而是为了自己的职业发展这个既定的大方向\n基层的员工要抬起头，而管理者要弯下腰\n适度的选择给我们自由，但是过多的选择会适得其反\n每个人钱的多少，反映了调用社会资源（包括自然和人两种资源）的总量，钱只有花出去才是自己的\n","date":"2020年2月7日","externalUrl":null,"permalink":"/posts/read-jianshi-summary/","section":"Posts","summary":"","title":"《见识》文摘","type":"posts"},{"content":" 背景 # 今年的年终总结提前了些，趁着自己刚换了个公司，索性把这一年多对前端开发的思考总结分享一下\n首先，我自己开始学前端是在大学时候就已经确定了，也是感觉做前端比较好玩有成就感，随即入坑，趁着移动互联网大众创新的大环境，从实习毕业到转正，后来换了两次工作，一路上还算比较的顺利，找工作也没遇到大的曲折，现在想想做前端也已经四年了（算上实习）。但是也正是因为这样的「顺利」，使得我还包括很多前端同学都忽略了很多我们作为前端工程师应该具备的东西\n到了今年，移动互联网的红利渐渐消失，全球经济下行，很多公司相继倒闭，裁员潮让很多人失去工作，或者很难找到工作。包括这次我也是在准备了很久才决定出去试试机会，面试求职的过程中会出现这样的情况：虽然对方感觉你已经很好了，但是还是要让你等很久才会给你答复，甚至有的 HR 打电话直接告诉我，“我们再比较下，会晚些给您 Offer”。\n所以在当前的环境下，为了让自己不被时代抛弃，掌握职业发展的主动权，思考成为一名优秀出众的前端工程师变的尤为重要，以下即是我的反思\n如何成为一名优秀的前端工程师 # 这个话题其实很多人都有自己的总结，包括业界大牛克军的内部分享《和团队谈个人成长》，我也是看了几遍，每次看都深有体会。说到成为优秀的前端工程师，很认同其中关于成长的描述，即成长包括客观因素和主观因素，下面就这两个方面说下我自己的想法吧\n客观因素 # 如果熟知 JavaScript 都知道有个 this 变量是指向环境上下文的，同样一个方法，this 指向不同，返回的内容就是不一样的，这就是环境的力量，同样一个人，处在的环境不同，成长的方向和进度也会大不同。\n我还没毕业就选择了在一家小创业公司开始实习，当时给我的感觉是兴奋的，因为这家公司很有朝气，部门的Leader 都很厉害，我在这家公司学到了很多东西，成长也很快。但是回过头来想一想，如果当时我能在一家大公司实习该多好啊，知乎上很多问题都讨论过毕业是进大公司还是小公司好。当时的我也很迷茫，没有意识到这个问题的重要性。\n现在让我回答，我肯定建议你先去大公司，当然前提是你实习的时候就很优秀，毕竟大公司要求还是比较严格的，其中有对基础知识和逻辑能力的考察，还会参考你所在学校的实力名气等。至于为什么选择去大公司，还是回到主题，那就是环境。\n大公司因为业务与技术的流程相对规范化，更适合一张白纸的毕业生去规范你的行为习惯、做事态度、思考方式等等，并且前端的基础设施也比较丰富，能让你学到很多工程化的东西，开阔视野，同时你的同事也都是业界优秀的人，能让你避免去走很多弯路，更注重人才的培养。\n小公司一般都处在业务扩张，迅速迭代的过程中，一方面，会让你一不小心就陷入业务的漩涡，导致缺乏总结思考的过程，另一方面，小公司也缺乏完善的基础设施做代码测试或者监控等流程，导致你对于性能的优化和产品的质量问题都比较模棱两可。这种环境会让你的成长很慢甚至产生对前端开发的误解，以为前端不过如此\n最近在看吴军老师的《见识》，他对年轻人职场的一个建议就是：\n人的第一份工作很重要，它的性质和成败决定了你此后职业发展的方向和事业起点\n所以，初入前端的人还是尽量靠自己的努力进入大厂，依靠这种环境资源，不断打磨自己，你就像一个产品，即使出去也是人人争抢\n说到打磨自己，下面就要谈谈主观因素了，主观因素其实就是靠自己，那么如何靠自己能够成为优秀的前端工程师呢？\n主观因素 # 我们大家都知道「玉」，好的玉，颜色剔透，色泽均匀，经过细心雕琢，成为精美的形状，随即成为市场上的“宠儿”。其实，我们每个前端工程师也都类似一块玉，不仅需要良好的内在品质，也需要经过不断的打磨才能成为一名优秀的工程师。\n所以，我把如何成为优秀的前端工程师主观因素分为两个部分，分别是素养（质地）和积累（雕琢）。\n素养 # 我自己认为比较重要的优秀前端工程师或者说是工程师的素养主要包括学习能力、革新能力、效率意识、严谨态度这四个方面\n学习 # 作为一名前端，学习是首要且重要的事情，前端技术的更迭的速度是十分快的，社区里很多人都在说「学不动了」这样的话，谁说不是呢？各种框架、库、工具、语言层出不穷，可能这个还没搞懂或者使用，又出了新的东西，让人感觉十分疲惫。但是我们大多时候其实都在学着怎么使用，而没有学这是什么原理，导致学的再多也只是皮毛。所以要学习就深入系统的学，构建自己的知识体系，比如 react 和 vue 的原理其实很多相通的地方，只需要搞懂一个的原理，另一个也就很容易就能理解，这样就减少了很多学习成本。同时要时刻保持学习的态度，半年不学习可能就跟不上技术的步伐了。\n革新 # 大家都在讲创新，那是因为改革与创新太重要了。一个拥有创新点子的工程师比照葫芦画瓢的工程师更能带动业务的发展，得到公司的认可。我自认为我也不是很会创新的人，但是我也会经常尝试着改变创新一些东西，不论是在用户体验还是效率上的。\n效率 # 说道效率，我总觉得「懒」确实是人类进步的动力来源。我在工作过程中，如果发现什么流程需要手动重复或者过程严重影响到了效率，我就会想怎么优化这个流程，不管是通过开发一个工具还是规范出一套流程。这样能让你省出很多时间来做其它的事情。拥有效率的意识，会让你更能优化你的工作流程，同时减少你加班的时间\n严谨 # 态度的严谨对于一个工程师是非常重要的，对于平常的优化工作，你不能说「快了很多」或者「占用内存更小了」，这样说，谁知道到底是快了多少，减少了多少内存的占用。而是要通过科学的实验，通过数据的形式输出。没有证据的支撑，没人会知道你到底做的有没有效果。很多大公司都有数据监控的一些基础设施，这些都是很好的参考依据。\n积累 # 拥有以上的内在品质还不够，那只能说明你是个质地良好的「石头」，还需要长期的积累与雕琢才能成为名个优秀的前端工程师。在积累上，我认为主要是知识的积累和经验的积累\n知识积累 # 作为一名技术，技术知识的积累是非常重要的，我也因为基础知识薄弱吃过很多亏，现在也在不断的补充学习。我理解的知识主要分为广度和深度两个方向的知识。\n在广度上，不仅要掌握前端的基础知识，还要夯实编程基础，比如软件工程方面的思想，设计模式，甚至还有上下游的知识，包括客户端、服务端、运维、测试、产品、设计等知识，都要知道了解一些，便于更好的沟通与理解所做的的工作。还有一点就是英语，作为一名优秀的技术，英语永远都是一个必须掌握的东西，因为很多资料都是用英语发表的，学好英语，就能拿到一手的资料，帮助我们更好的理解一个新事物，并能开阔我们的视野。\n在深度上，最好深精一个你愿意去研究的技术方向，比如node、数据可视化、3D技术、编辑器、地图等等，毕竟做技术不能大而全，最后什么都做不好，选定一个方向，常年深耕，说不定你就是这个方向的技术专家了\n技术知识的积累，建议以看书为主，因为书上的内容更加体系，更能让你深入的去理解。技术社区的文章为辅，通过别人的视角去看这门技术。同时要不断做些项目，纸上谈兵的技术终究是纸老虎\n经验积累 # 说完知识的积累，还有一个方面就是经验的积累了，这些东西是书本上学不到了，只有你经历了总结了，才是你的沉淀。比如说项目的经验，业务千千万，遇到的问题，踩到的坑都是你的宝贵经验，可以为你以后的项目提供了可靠的参考\n所以在工作中要多去总结我们的业务，遇到的坑多去反思，形成自己的一套技术方案。优秀的工程师在遇到每个问题都能拿出至少一种的解决方案，快速的落地解决问题。\n经验的积累不止这些，还有包括技术架构设计、管理带团队的经验等等，当然要拥有这些经验，除了自己努力，也要靠机遇了，也就是是上面说的客观环境因素了\n总结 # 通常，通过自己主观的努力，是可以改变自己所处的客观环境的，更好的客观环境又能促进你的技能学习和经验的积累，从而实现正向循环。\n以上就是我认为的如何做一名优秀前端工程师的方法。当然这些也都是根据我的所见所闻，包括工作经历、面试过程、看到的文章或书的一些归纳。我也不认为我是个优秀的前端工程师，其中有很大一部分我也在自我提升，不断学习中。\n以上分享若能给你带来一点点启发与共鸣，我将倍感荣幸\n","date":"2019年11月23日","externalUrl":null,"permalink":"/posts/front-end-development-career-reflection-in-2019/","section":"Posts","summary":"","title":"成为一名优秀的前端工程师","type":"posts"},{"content":" 定位自己，关注自己当前阶断的积累，聚焦拐点，均衡发展。有些能力必须要有历经时间和反复历练形成的成熟度。不要试图跳跃、不要急于求成、不要忽视全面均衡的发展。不要成为职场“豆芽菜”。\n浮躁就是只关注解决问题的手段，没有真正提高解决问题能力。修炼自己的元能力。\n电影《天才捕手》。在工作中，要积累真实的感受。看再多的书和文章，没有实践，没有在实际的应用场景中应用，都不算有效的经验。\n工作中保持痛感，感受快乐是最好的工作状态！ 做不同的事情，内心感受是不同的。当你觉得无感时，说明你对技术细节的认知还不够，只是简单的重复。需要通过学习其中所有的技术点来提高技巧。同时，需要不断深入理解，感受实践中用到的技术和工具所发挥的作用。形象的说就是知识的“分辨率”怎么样，是模模糊糊的，还是\u0026quot;精度\u0026quot;很高，了解每一个细微的技术点。你会发现，有太多东西值得探索。只有在具体实践中才有体感，脱离应用场景啃一本书没有用的。进一步，你才能准确定义和抽象出开发中的普便问题。这是提高纵轴挑战水平的方式。所以，不必刻意寻找有挑战、有难度的工作做。重要的是，你能不能潜的更深，积累下更多的有价值的感受。\n如果你正在做一件本身挑战很大的事，这时无须再增加挑战水平（纵轴）而是通过发现和学习已知的未知（对应问题域的知识域）技术来解决问题（横轴）。这时候需要拆解目标，降低挑战，耐心从基础开始学习。内心需要克服浮躁和自我怀疑的情绪。没有银弹能解决所有问题。关注前端技术发展，保持学习是十分重要的。\n任何一种心理状态都不是一成不变的。比如一些能力不错的同学，对于常规需求，处于完全“掌控”的状态。但干的久了，一直做类似的事情挑战水平自然会衰减，通常会进入“无聊”的状态。然后常常会说工作太无聊，缺乏挑战，一成不变。其实是你主观意识上没有加深工作的感受，只是被动的被支配做一些事。经常反省自己所处的状态，每一件事努力做到心流（同时提高纵轴和横轴）\n心态管理很重要，尤其是底部状态管理。面对工作中的挫败、不爽、消极、想放弃的情绪，这些都是很正常的起起伏伏。人在做一件事的中途是最敏感、脆弱，最容易自我怀疑的，很容易怀疑目标和方向，半途而废，前功尽弃，这就是所谓的半途效应。在做一些挑战很大、路径很长的事情时，动机不要太强。急躁、焦虑会干扰正常的思维水平（多德森法则）。\n原文地址：https://weibo.com/ttarticle/p/show?id=2309404300456787613157\n​​​​\n","date":"2019年11月22日","externalUrl":null,"permalink":"/posts/kejun-how-to-be-awesome-fe/","section":"Posts","summary":"","title":"和团队谈个人成长-克军 [转载]","type":"posts"},{"content":"自从2018年过年买了 kindle ，真的是让我多读了不少书，当然也促进了我的睡眠，甚至后悔没有早点入手。2018已经过去几天了，整理一下去年读的一些书，做一个回顾和归档。\n《精进：如何成为一个很厉害的人》 # 这本书是关于时间、行动、思维等自我提升主题的探索。\n我的主要摘录：\n一个人如何对待他的时间，决定了他可以成为什么样的人\n在分析一件事情值不值得去做、花多少精力去做的时候，可以从两个角度来评估：一是这件事在当下将给“我”带来的收益大小，这个收益可以是心智、情感层面的，也可以是身体、物质层面的，我称之为“收益值”；二是这项收益随时间衰减的速度，我称之为“收益半衰期”，半衰期长的事件，其影响会持续\n实际做事花费的时间总是比预期的要长，即使预期中考虑了侯世达\n从理论出发不一定能指导实践，只有在实践中通过反思积累的知识才能指导\n不要只做信息的搬运工 通过解码，深入事物的\n《创京东》（刘强东亲述创业之路） # 这个本书介绍了刘强东创业的心血历程，从实体小店铺到京东帝国，让我对创业这件事多了许多敬畏\n我的主要摘录：\n如果这事大家都觉得能够做成，那它的价值能有多大呢?正因为大家都觉得做不成，这件事才具备更大的可能性\n《我遇见了人类》 # 这本书写了一个外星人潜入主人公的身体，并发生了一系列的让这个外星人莫名其妙的事，最后映射出来的是人类世界的温暖\n我的主要摘录：\n我窃笑，人类生来就被关押在一具会死的躯壳里，他们居然会更害怕被关押在房间里！\n在地球上，文明是人类聚集在一起共同压抑本能的结果\n做人意味着，小时候在圣诞节可以收到一座华丽壮观的城堡，盒子上有一张美轮美奂的城堡的照片，你整天都只想摆弄着城堡以及城堡里的骑士和公主，因为它看起来就像一个完美的人类世界。可唯一的问题在于城堡并没有建好，它只是一些错综复杂的小碎块，尽管盒子里附送了一本说明书，但你怎么也看不懂，你的父母还有阿姨也看不懂。所以你只好被扔在原地，望着盒子上永远无法建起的完美城堡号陶大哭。\n《前端工程化：体系设计与实践》 # 这本书帮助系统了解前端工程化的相关知识，介绍的是前端工程中脚手架、开发构建、部署、工作流等方面的问题\n《半小时漫画世界史》 # 使用风趣幽默的漫画方式讲解了世界史的变迁，读着感觉很有意思，但是读完我就忘完了，哈哈\n《谁动了我的奶酪》 # 一本很薄的书，讲的是两只小老鼠和两个小矮人关于奶酪的故事。读下来就能立马明白其中的意思。大意就是告诫人们要拥抱变化，不断努力和探索。而贪图安逸，默守陈规，只会让你的生活变得糟糕，所以这本书就是劝诫人们要保持焦虑，哈哈哈\n《我们为什么会发胖》 # 因为今年在健身，所以就想了解下饮食相关的知识，书如其名，告诉我们为什么会发胖\n我的主要摘录：\n肥胖归根结底是由激素失衡，而不是卡路里失衡造成的。具体而言就是，食用易消化、富含糖类的食物会刺激胰岛素分泌。这类食物有：精加工的糖类（包括面粉和谷类），马铃薯这样含有淀粉的蔬菜，以及食用糖（如蔗糖和果葡糖浆等）。这些糖类确实会使我们发胖，由于脂肪的累积会让我们感到更饿，于是我们吃得也更多，加之久坐不动，所以更容易\n在质疑“饮食过度导致肥胖”的所有原因中，最明显的事实一直是， 少吃并不能治疗\n《特朗普自传》 # 这本书也是属于蹭热度看的，但是看了还没有一半，感觉总统的生活实在太啰嗦了，就没有继续看下去\n《白夜行 (东野圭吾作品) 》 # 这本书是我17年开始看的，然而看了一半感觉前面太啰嗦，然后就停滞了一段时间，18年继续看下去，发现后面是真的精彩，看的我头皮发麻。总之这本书写的很压抑，毕竟是东野圭吾的书，好像都是这个风格。这本书让我认识到，每个人童年时期受到的影响会映射到他的一辈子，所以我在想其实人性是本善的，只是在你成长的过程中，可能会受到各种侵染，如果受到很大的刺激，会影响一辈子，甚至会报复社会。人生之棋，一步走错，满盘阴影。童年是很重要的人生阶段。\n我的主要摘录：\n看个人，有些人一辈子都活在太阳的照耀下，也有些人不得不一直活在漆黑的深夜里。人害怕的，就是本来一直存在的太阳落下不再升起，也就是非常害怕原本照在身上的光芒消失，现在的夏美就是\n“我的天空里没有太阳，总是黑夜，但并不暗，因为有东西代替了太阳。虽然没有太阳那么明亮，但对我来说已经足够。凭借着这份光，我便能把黑夜当成白天。你明白吧？我从来就没有太阳，所以不怕\n《论中国》 # 这本书是从美国人基辛格的角度来看中国的历史变迁和中国人的特性，多了些客观参考性\n《不可不知的经济真相》 # 浅显易懂的讲了中国经济上的一些名词和历史变迁，让我对经济危机、中国的经济模式、投资等问题有了更深的了解，非常适合我这种经济小白，总体感觉不错\n我的主要摘录：\n创新，创新，我们几乎天天挂在嘴边，却忽略了它的真正含义是创造新的需求，而一旦有了新的需求，经济就能冲破雾\n普通人满足需求，卓越者创造需求\n所有的过剩产能，都是由当初的恶性竞争和过剩供给导致\n一个人能承担多大的风险，其实并不取决于他的胆量大小，也不取决于是否有夜夜安枕的良好心态，而是取决于他的收入水平\n你无须拥有，却能愉快使用，这就是共享\n泡沫为何会反复发生，这是因为千百年来人性不变。人们内心当中总是有着最原始的贪婪和恐惧，贪婪会把人们推向疯狂的天堂，恐惧会撕碎泡沫并把人们推向无尽的深渊\n他说不管经济繁荣还是衰退，专注于自己核心的业务永远是生存\n以上就是2018所有的读书总结摘录，其实还有一些没有列举，大部分是没有读完或者没什么印象的书，哈哈哈，ok，2019 继续！\n","date":"2019年1月6日","externalUrl":null,"permalink":"/posts/2018%E6%88%91%E7%9A%84%E4%B8%AA%E4%BA%BA%E4%B9%A6%E5%8D%95/","section":"Posts","summary":"","title":"2018我的个人书单","type":"posts"},{"content":"","date":"2018年12月15日","externalUrl":null,"permalink":"/tags/javascript/","section":"Tags","summary":"","title":"JavaScript","type":"tags"},{"content":"","date":"2018年12月15日","externalUrl":null,"permalink":"/tags/map/","section":"Tags","summary":"","title":"Map","type":"tags"},{"content":"","date":"2018年12月15日","externalUrl":null,"permalink":"/tags/set/","section":"Tags","summary":"","title":"Set","type":"tags"},{"content":" 特性比较 Set WeakSet Map WeakMap 初始化 new Set([1,2,3,4]) new WeakSet([1,2,3,4]) new Map([[\u0026quot;name\u0026quot;, \u0026quot;Bright\u0026quot;], [\u0026quot;sex\u0026quot;, \u0026quot;男\u0026quot;]]) new WeakMap([[\u0026quot;name\u0026quot;, \u0026quot;Bright\u0026quot;], [\u0026quot; sex\u0026quot;, \u0026quot;男\u0026quot;]]) 定义 一种包含多个非重复值的有序列表 是一种特殊的 Set 集合，集合只支持存放对象弱引用 一种多个键值对组成的有序集合 是一种特殊的 Map 集合，只支持对象类型的键名 可否迭代 是 否 是 否 引用特性 成员对象强引用 成员对象弱引用 成员对象强引用 成员对象弱引用 属性方法 add() has() delete() clear() forEach() keys() values() size add() has() delete() set() get() has() delete() clear() forEach() keys() values() size set () get() has() delete() 使用建议 由于对象判断属性存在的局限性，此集合更适用于检测给定的值在集合中是否存在。同时基于本身无重复值的特性，可做数组的去重 只可存放对象类型，并方便引用对象的跟踪 用于处理键值对数据，存放需要经常存取的数据 用于处理键值对数据，键名只可存放对象类型，并方便引用对象的跟踪，最大用途是保存 Web 页面的 DOM 元素 可否迭代 # 是否可迭代用于表示该集合是否支持遍历成员属性，支持包括 forEach()、keys()、values()、for\u0026hellip;of 等方法的使用\n对象局限性 # 对象中使用 if 来判断一个值的是否存在不够严谨，当属性本身不存在和存在并且值为 false 时，得到的判断结果是一样的，这就会带来问题。还有一种判断对象中属性是否存在的方法 in, 但是该方法会向上遍历继承的原型属性，同样带来一些未知问题，除非该对象继承自 null。\n强引用 # 只要引用存在，垃圾回收机制不会释放被引用对象的内存空间\n弱引用 # 引用对象被置空，集合不保存该引用，触发垃圾回收机制\n","date":"2018年12月15日","externalUrl":null,"permalink":"/posts/set%E9%9B%86%E5%90%88%E4%B8%8Emap%E9%9B%86%E5%90%88%E6%AF%94%E8%BE%83/","section":"Posts","summary":"","title":"Set集合与Map集合比较","type":"posts"},{"content":"","date":"2018年12月15日","externalUrl":null,"permalink":"/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/","section":"Categories","summary":"","title":"前端开发","type":"categories"},{"content":"","date":"2018年12月15日","externalUrl":null,"permalink":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","section":"Tags","summary":"","title":"数据结构","type":"tags"},{"content":"","date":"2018年9月1日","externalUrl":null,"permalink":"/tags/web%E4%BC%98%E5%8C%96/","section":"Tags","summary":"","title":"Web优化","type":"tags"},{"content":"网页加载速度是衡量一个网页好坏的重要标准，网页遗弃率随网页加载时间的增加而增加。据说近一半的用户希望网页加载时间不超过2s，超过3s一般就放弃该网页。时间就是生命，干等着，谁愿意平白无故地+1s呀，所以今天来整理下具体如何加快网页\nHTML # 压缩 HTML: HTML代码压缩，将注释、空格和新行从生产文件中删除。\n为什么：\n删除所有不必要的空格、注释和中断行将减少HTML的大小，加快网站的页面加载时间，并显著减少用户的下载时间。\n怎么做：\n大多数框架都有插件用来压缩网页的体积。你可以使用一组可以自动完成工作的NPM模块。\n🛠 HTML minifier | Minify Code 📖 Experimenting with HTML minifier — Perfection Kills 删除不必要的注释： 确保从您的网页中删除注释。\n为什么：\n注释对用户来说是没有用的，应该从生产环境文件中删除。可能需要保留注释的一种情况是：保留远端代码库（keep the origin for a library）。\n怎么做：\n大多数情况下，可以使用HTML minify插件删除注释。\n🛠 remove-html-comments - npm 删除不必要的属性： 像 type=\u0026quot;text/javascript\u0026quot; or type=\u0026quot;text/css\u0026quot; 这样的属性应该被移除。\n\u0026lt;!-- Before HTML5 --\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; // Javascript code \u0026lt;/script\u0026gt; \u0026lt;!-- Today --\u0026gt; \u0026lt;script\u0026gt; // Javascript code \u0026lt;/script\u0026gt; 为什么\n类型属性不是必需的，因为HTML5把text/css和text/javascript作为默认值。没用的代码应在网站或应用程序中删除，因为它们会使网页体积增大。\n怎么做：\n⁃ 确保所有link和script标记都没有任何type属性。\n📖 The Script Tag | CSS-Tricks 在JavaScript引用之前引用CSS标记： 确保在使用JavaScript代码之前加载CSS。\n为什么：\n在引用JavaScript之前引用CSS可以实现更好地并行下载，从而加快浏览器的渲染速度。\n怎么做：\n确保 head 中的 link 和 style 始终位于 script 之前。\n最小化iframe的数量： 仅在没有任何其他技术可行性时才使用iframe。尽量避免使用iframe。\nDNS预取： 一次 DNS 查询时间大概在60-120ms之间或者更长，提前解析网页中可能的网络连接域名\n\u0026lt;link rel=\u0026#34;dns-prefetch\u0026#34; href=\u0026#34;http://example.com/\u0026#34;\u0026gt; CSS # 压缩: 所有CSS文件都需要被压缩，从生产文件中删除注释，空格和空行。\n为什么：\n缩小CSS文件后，内容加载速度更快，并且将更少的数据发送到客户端，所以在生产中缩小CSS文件是非常重要，这对用户是有益的，就像任何企业想要降低带宽成本和降低资源。\n怎么做：\n使用工具在构建或部署之前自动压缩文件。\n🛠 cssnano: 基于PostCSS生态系统的模块化压缩工具。 🛠 @neutrinojs/style-minify - npm Concatenation: CSS文件合并（对于HTTP/2效果不是很大）。\n\u0026lt;!-- 不推荐 --\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;foo.css\u0026#34;/\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;bar.css\u0026#34;/\u0026gt; \u0026lt;!-- 推荐 --\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;foobar.css\u0026#34;/\u0026gt; 为什么：\n如果你还在使用HTTP/1，那么你就需要合并你的文件。不过在使用HTTP/2的情况下不用这样（效果待测试）。\n怎么做：\n在构建或部署之前使用在线工具或者其他插件来合并文件。 当然，要确保合并文件后项目可以正常运行。\n📖 HTTP: 优化应用程序交付 - 高性能浏览器网络 (O\u0026rsquo;Reilly) 📖 HTTP/2时代的性能最佳实践 非阻塞： CSS文件需要非阻塞引入，以防止DOM花费更多时间才能渲染完成。\n\u0026lt;link rel=\u0026#34;preload\u0026#34; href=\u0026#34;global.min.css\u0026#34; as=\u0026#34;style\u0026#34; onload=\u0026#34;this.rel=\u0026#39;stylesheet\u0026#39;\u0026#34;\u0026gt; \u0026lt;noscript\u0026gt;\u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;global.min.css\u0026#34;\u0026gt;\u0026lt;/noscript\u0026gt; 为什么：\nCSS文件可以阻止页面加载并延迟页面呈现。使用preload实际上可以在浏览器开始显示页面内容之前加载CSS文件。\n怎么做：\n需要添加rel属性并赋值preload，并在\u0026lt;link\u0026gt;元素上添加as=“style”。\n📖 loadCSS by filament group 📖 使用loadCSS预加载CSS的示例 📖 使用rel =“preload”预加载内容 📖 Preload: What Is It Good For? — Smashing Magazine CSS类(class)的长度: class的长度会对HTML和CSS文件产生（轻微）影响。\n为什么：\n甚至性能影响也是有争议的，项目的命名策略会对样式表的可维护性有重大影响。如果使用BEM，在某些情况下可能会写出比所需要的类名更长的字符。重要的是要明智的选择名字和命名空间。\n怎么做：\n可能有些人更关注类名的长度，但是网站按组件进行划分的话可以帮助减少类名的数量和长度。\n🛠 long vs short class · jsPerf 不用的CSS: 删除未使用的CSS选择器。\n为什么：\n删除未使用的CSS选择器可以减小文件的大小，提高资源的加载速度。\n怎么做：\n⚠️ 检查要使用的CSS框架是否已包含reset/normalize代码，可能不需要用到reset/normalize文件中的内容。\n🛠 UnCSS Online 🛠 PurifyCSS 🛠 PurgeCSS 🛠 Chrome DevTools Coverage JavaScript # JS 压缩: 所有JavaScript文件都要被压缩，生产环境中删除注释、空格和空行（在HTTP/2仍然有效果）。\n为什么：\n删除所有不必要的空格、注释和空行将减少JavaScript文件的大小，并加快网站的页面加载时间，提升用户体验。\n怎么做：\n建议使用下面的工具在构建或部署之前自动缩小文件。\n📖 uglify-js - npm 📖 Short read: How is HTTP/2 different? Should we still minify and concatenate? 非阻塞JavaScript： 使用defer属性或使用async来异步加载JavaScript文件。\n\u0026lt;!-- Defer Attribute --\u0026gt; \u0026lt;script defer src=\u0026#34;foo.js\u0026#34;\u0026gt; \u0026lt;!-- Async Attribute --\u0026gt; \u0026lt;script async src=\u0026#34;foo.js\u0026#34;\u0026gt; 为什么：\nJavaScript阻止HTML文档的正常解析，因此当解析器到达script标记时（特别是在内），它会停止解析并且执行脚本。如果您的脚本位于页面顶部，则强烈建议添加async和defer，但如果在标记之前加载，没有太大影响。但是，使用这些属性来避免性能问题是一种很好的做法。\n怎么做：\n添加async（如果脚本不依赖于其他脚本）或defer（如果脚本依赖或依赖于异步脚本）作为script脚本标记的属性。 如果有小脚本，可以在异步脚本上方使用内联脚本。\n📖 Remove Render-Blocking JavaScript 使用 tree shaking 技术减少 js 大小: 通过构建工具分析 JavaScript 代码并移除生产环境中用不到的 js 模块或方法\n📖 Reduce JavaScript Payloads with Tree Shaking 使用 code splitting 分包加载 js: 通过分包加载，减少首次加载所需时间\n怎么做：\nVendor splitting 根据库文件拆分模块，例如 React 或 lodash 单独打包成一个文件 Entry point splitting 根据入口拆分模块，例如通过多页应用入口或者单页应用路由进行拆分 Dynamic splitting 根据动态加载拆分模块，使用动态加载语法 import() ，实现模块按需加载\n📖 Reduce JavaScript Payloads with Tree Shaking 图片资源 # 📖 Image Bytes in 2018\n图像优化: 在保证压缩后的图片符合产品要求的情况下将图像进行优化。\n为什么：\n优化的图像在浏览器中加载速度更快，消耗的数据更少。\n怎么做：\n尽可能尝试使用CSS3效果（而不是用小图像替代） 尽可能使用字体图片 使用 SVG 使用编译工具并指定85以下的级别压缩。\n📖 Image Optimization | Web Fundamentals | Google Developers 🛠 TinyJPG – Compress JPEG images intelligently 🛠 Kraken.io - Online Image Optimizer 🛠 Compressor.io - optimize and compress JPEG photos and PNG images 🛠 Cloudinary - Image Analysis Tool 图像格式： 适当选择图像格式。\n为什么：\n确保图片不会减慢网站速度\n怎么做：\n使用Lighthouse识别哪些图像可以使用下一代图片格式（如JPEG 2000m JPEG XR或WebP）。 比较不同的格式，有时使用PNG8比PNG16好，有时候不是。\n📖 Serve Images in Next-Gen Formats | Tools for Web Developers | Google Developers 📖 What Is the Right Image Format for Your Website? — SitePoint 📖 PNG8 - The Clear Winner — SitePoint 📖 8-bit vs 16-bit - What Color Depth You Should Use And Why It Matters - DIY Photography 使用矢量图像 VS 栅格/位图： 可以的话，推荐使用矢量图像而不是位图图像。\n为什么：\n矢量图像（SVG）往往比图像小，具有响应性和完美缩放功能。而且这些图像可以通过CSS进行动画和修改操作。\n图像尺寸： 如果已知最终渲染图像大小，请在上设置宽度和高度属性。\n为什么：\n如果设置了高度和宽度，则在加载页面时会保留图像所需的空间。如果没有这些属性，浏览器就不知道图像的大小，也无法为其保留适当的空间，导致页面布局在加载期间发生变化。\n避免使用Base64图像： 你可以将微小图像转换为base64，但实际上并不是最佳实践。\n📖 Base64 Encoding \u0026amp; Performance, Part 1 and 2 by Harry Roberts 📖 A closer look at Base64 image performance – The Page Not Found Blog 📖 When to base64 encode images (and when not to) | David Calhoun 📖 Base64 encoding images for faster pages | Performance and seo factors 懒加载： 图像懒加载（始终提供noscript作为后备方案）。\n为什么：\n它能改善当前页面的响应时间，避免加载一些用户可能不需要或不必要的图像。\n怎么做：\n使用Lighthouse可以识别屏幕外的图像数量。 使用懒加载图像的JavaScript插件。\n🛠 verlok/lazyload: Github 📖 Lazy Loading Images and Video | Web Fundamentals | Google Developers 📖 5 Brilliant Ways to Lazy Load Images For Faster Page Loads - Dynamic Drive Blog 响应式图像： 确保提供接近设备显示尺寸的图像。\n为什么：\n小型设备不需要比视口大的图像。建议在不同尺寸上使用一个图像的多个版本。\n怎么做：\n为不同的设备设置不同大小的图像。 使用srcset和picture为每个图像提供多种变体（variants）。\n📖 Responsive images - Learn web development | MDN 服务部署 # 页面大小 \u0026lt; 1500 KB: (理想情况 \u0026lt; 500 KB) 尽可能减少页面和资源的大小。\n为什么：\n理想情况下，应该尝试让页面大小\u0026lt;500 KB，但Web页面大小中位数大约为1500 KB（即使在移动设备上）。根据你的目标用户、连接速度、设备，尽可能减少页面大小以尽可能获得最佳用户体验非常重要。\n怎么做：\n前端性能清单中的所有规则将帮助你尽可能地减少资源和代码。\n📖 Page Weight 🛠 What Does My Site Cost? Cookie 大小: 如果您使用cookie，请确保每个cookie不超过4096字节，并且一个域名下不超过20个cookie。\n为什么：\ncookie存在于HTTP头中，在Web服务器和浏览器之间交换。保持cookie的大小尽可能低是非常重要的，以尽量减少对用户响应时间的影响。\n怎么做：\n消除不必要的cookie\n📖 Cookie specification: RFC 6265 📖 Cookies 🛠 Browser Cookie Limits 📖 Website Performance: Cookies Don\u0026rsquo;t Taste So Good - Monitis Blog 📖 Google\u0026rsquo;s Web Performance Best Practices #3: Minimize Request Overhead - GlobalDots Blog 最小化HTTP请求： 始终确保所请求的每个文件对网站或应用程序至关重要，尽可能减少http请求。\n使用CDN提供静态文件： 使用CDN可以更快地在全球范围内获取到你的静态文件。\n📖 10 Tips to Optimize CDN Performance - CDN Planet 📖 HTTP Caching | Web Fundamentals | Google Developers 正确设置HTTP缓存标头： 合理设置HTTP缓存标头来减少http请求次数。\n启用GZIP压缩\n📖 Check GZIP compression 分域存放资源： 由于浏览器同一域名并行下载数有限，利用多域名主机存放静态资源，增加并行下载数，缩短资源加载时间\n减少页面重定向\n以上清单仅为节选，来源 https://github.com/w3cay/Front-End-Performance-Checklist\n","date":"2018年9月1日","externalUrl":null,"permalink":"/posts/web%E5%8A%A0%E8%BD%BD%E9%80%9F%E5%BA%A6%E4%BC%98%E5%8C%96%E6%B8%85%E5%8D%95/","section":"Posts","summary":"","title":"Web加载速度优化清单","type":"posts"},{"content":"","date":"2018年9月1日","externalUrl":null,"permalink":"/tags/%E5%89%8D%E7%AB%AF/","section":"Tags","summary":"","title":"前端","type":"tags"},{"content":"","date":"2018年9月1日","externalUrl":null,"permalink":"/tags/%E5%8A%A0%E8%BD%BD%E9%80%9F%E5%BA%A6/","section":"Tags","summary":"","title":"加载速度","type":"tags"},{"content":"","date":"2018年9月1日","externalUrl":null,"permalink":"/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/","section":"Tags","summary":"","title":"性能优化","type":"tags"},{"content":" 引语 # 之前花了一些时间把《精进，如何成为一个很厉害的人》读完了，首次看到这个书名，想着这书应该类似那种成功学的书，看了一些，虽然确实（像）是成功学，但是里面作者所描述的思想和价值观还是很中肯和值得揣摩的。所以对于一些我比较认同的和感兴趣的点，我把它提取出来，分享出来\n文摘 # 一个人如何对待他的时间，决定了他可以成为什么样的人\n每个人的生命时间都是有限的，在有限的时间里做有意义的事情，国家有5年计划，为何我们不能有？计划可以让你更有目的的去生活，制定自己的计划，利用好时间，活成自己想要的样子\n在分析一件事情值不值得做或者需要花精力去做的时候，一方面可以先想想这件事给我带来的收益大小，比如可以是心智、情感层面，也可以是身体、物质层面的，另一方面，看这个收益能影响多长的时间，或者叫“收益半衰期”\n每个人的时间都是成本的，虽然不是商人，那也要考虑收益，要把自己当做投资人\n侯世达定律：实际做事花费的时间总是比预期要长，即使预期中考虑了侯世达定律\n作为技术人员，这个定律一定是深入人心，排期再怎么详尽和合理，但是因为这个世界存在很多的不确定因子，突发事件是你无法预测的，所以只能尽力去完成你的预期，如果定期完成了，那是件值得庆幸的事\n牛人总是在前瞻性思维和总结性思维上都非常出色，他们既能提前设想未来事件中可能出现的方方面面的情形，又能从已经发生的行动中加以反思，因此他们总是比一般人想得更加深入和周全\n我的总结 “向前看、向后看、低头看”\n从理论出发不一定能指导实践，只有在实践中通过反思积累的知识才能指导\n不论学习什么东西，肯定是参与其中实践，才能看清你所要学习的内容的本质，或者说更好的帮助你的理解\n独特性，就是最好的竞争力，请坚持你的与众不同\n如果学的东西 （输入） 和 做的东西 （输出） 和别人都一样，没有任何独到和与众不同的东西，那么你就会被淹没在乌央乌央的人群中，所以看到什么东西，要先自己思考，然后参考别人的东西，然后在反复思考验证中得到你的东西\n总结 # 作者从时间、学习、思维方式、技能等方面描述了一个人如何成为一个厉害的人，总体感觉不错，部分内容感觉还没参透或有些枯燥，我只摘选了小部分内容，有兴趣的人可以自己看一下\n","date":"2018年8月19日","externalUrl":null,"permalink":"/posts/%E8%AF%BB%E7%B2%BE%E8%BF%9B%E7%A2%8E%E8%AF%AD%E6%96%87%E6%91%98%E4%B8%8E%E6%84%9F%E6%83%B3/","section":"Posts","summary":"","title":"《精进，如何成为一个很厉害的人》文摘","type":"posts"},{"content":"","date":"2018年8月5日","externalUrl":null,"permalink":"/tags/react/","section":"Tags","summary":"","title":"React","type":"tags"},{"content":" react-city-select # 基于 React 的可配置化城市列表选择组件\ndemo: https://blog.caydock.com/react-city-select/example/\n安装 # npm i react-city-select 或 yarn add react-city-select 使用 # ... // 引入 CitySelect 组件 import CitySelect from \u0026#39;react-city-select\u0026#39;; // 引入数据 import data from \u0026#39;./data.json\u0026#39;; // 引入图标路径 import iconSrc from \u0026#39;./location_icon@2x.png\u0026#39;; export default class APP extends React.Component { constructor(props) { super(props); this.state = { // 结构化城市列表数据 citysData: data.indexCitys, // 对某项数据定制化配置 config: { pos: { icon: iconSrc, // 游标图标 title: \u0026#39;定位城市\u0026#39;, }, hot: { title: \u0026#39;热门城市\u0026#39;, key: \u0026#39;热门\u0026#39;, style: \u0026#39;grid\u0026#39;, // 展示形式（ line || grid） } } }; } // 选中城市回调 handleSelectCity(cityData) { console.log(\u0026#39;选中数据项:\u0026#39;, cityData); } render() { return ( \u0026lt;CitySelect // 传入数据 data={this.state.citysData} // 传入配置 config={this.state.config} // 传入回调 onSelectItem={this.handleSelectCity.bind(this)}\u0026gt; \u0026lt;/CitySelect\u0026gt; ) } } props 参数 # 属性 值 说明 data 必填；对象； 城市组件数据JSON对象 config 可选；对象； 配置或覆盖某个 key 下的值，详情见下表 onSelectItem 必填；函数； 点击单元格数据回调 config 参数 # 属性 值 说明 config[\u0026lsquo;sec-key\u0026rsquo;][\u0026rsquo;title\u0026rsquo;] 可选；字符串； 索引标题 config[\u0026lsquo;sec-key\u0026rsquo;][\u0026lsquo;key\u0026rsquo;] 可选；字符串； 游标标题 config[\u0026lsquo;sec-key\u0026rsquo;][\u0026lsquo;icon\u0026rsquo;] 可选；字符串； 游标图标（替代标题） config[\u0026lsquo;sec-key\u0026rsquo;][\u0026lsquo;style\u0026rsquo;] 可选；字符串；(line或grid) 数据项展示方式 sec-key : 对象key\ndata 数据格式 # // 定位数据项 \u0026#34;pos\u0026#34;: [{ \u0026#34;id\u0026#34;: \u0026#34;110100\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;北京\u0026#34; }], // 热门数据项 \u0026#34;hot\u0026#34;: [{ \u0026#34;id\u0026#34;: \u0026#34;110100\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;北京\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;120100\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;天津\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;130100\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;石家庄\u0026#34; } ], // 字母数据项 \u0026#34;A\u0026#34;: [{ \u0026#34;id\u0026#34;: \u0026#34;152900\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;阿拉善盟\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;210300\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;鞍山\u0026#34; } ], \u0026#34;B\u0026#34;: [{ \u0026#34;id\u0026#34;: \u0026#34;110100\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;北京\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;130600\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;保定\u0026#34; } ] ... Github 仓库地址： https://github.com/w3cay/react-city-select\n","date":"2018年8月5日","externalUrl":null,"permalink":"/posts/react%E5%8F%AF%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%9B%BD%E5%9F%8E%E5%B8%82%E5%88%97%E8%A1%A8%E9%80%89%E6%8B%A9%E7%BB%84%E4%BB%B6/","section":"Posts","summary":"","title":"React可配置中国城市列表选择组件","type":"posts"},{"content":"","date":"2018年8月5日","externalUrl":null,"permalink":"/tags/%E5%9F%8E%E5%B8%82%E9%80%89%E6%8B%A9/","section":"Tags","summary":"","title":"城市选择","type":"tags"},{"content":"","date":"2018年8月5日","externalUrl":null,"permalink":"/tags/%E7%BB%84%E4%BB%B6/","section":"Tags","summary":"","title":"组件","type":"tags"},{"content":"在使用 React 的过程中（ES6 Class 语法下），我一直很疑惑一件事情，那就是事件的绑定，比如 onClick、onChange 的事件处理函数必须这样写\n\u0026lt;button onClick={this.handleClick.bind(this)}\u0026gt;点击\u0026lt;/button\u0026gt; 或者在 constructor 函数中声明\nthis.handleClick = this.handleClick.bind(this); 疑惑 # 为什么明明是使用的是 this 下面的函数，还要绑定 bind 一下 this 呢? 就好比『我想用自己的手机还要声明下这是我的手机』，不说写法是否正确，自我感觉代码的可读性和美观度都不佳\n解析 # Javascript 是一种比较特殊的语言，说起这个问题要从作用域谈起，首先，JavaScript 是只有静态作用域的，没有动态作用域，或许有人说 this 不是吗？NO，它只是像而已\n顾名思义，静态作用域就是说作用域由你的代码书写位置决定的，而动态作用域的作用域是调用执行的时候确定的，没错 this 就是这样的\nthis 的作用就是找到函数被调用所绑定的位置，那么位置寻找是有规则的，下面是四条寻找规则\n一、 默认绑定 默认绑定，顾名思义，就是无法应用其它规则的时候使用的绑定规则，这种规则也是函数中最常用的，叫做独立函数调用，例如：\nfunction foo() { console.log( this.a ); } var a = 2; foo(); // 2 foo 不带任何修饰的函数引用进行调用，只能使用默认绑定规则 这时，this 的指向默认是全局作用域，即 window ,当然是在非严格模式下。在严格模式下就会是 undefined\n二、 隐式绑定 还有一种情况，函数存在于对象中，被对象所引用，例如\nfunction foo() { console.log( this.a ); } var obj = { a: 2, foo: foo }; obj.foo(); // 2 这种情况 this 绑定的就是 obj， 因为函数存在于对象之中，并且被该对象所调用。 即使 foo 函数存在于对象内部，但有时也会找不到它的上下文，比如\nfunction foo() { console.log( this.a ); } var obj = { a: 2, foo: foo }; //将 foo 函数赋值给一个变量 var bar = obj.foo; bar(); // undefined 此时，函数 bar 是对 obj.foo 的一个引用，严格来说，跟对象 obj 没有任何关系，此时 bar 的执行就可以运用默认绑定规则，所以它的上下文this 指向 window 或者 undefined\n还有一种情况，就是在回调函数中引用，也会出现找不到上下文，造成 this 绑定丢失\nfunction foo() { console.log( this.a ); } var a = \u0026#39;window a\u0026#39;; var obj = { a: \u0026#39;obj a\u0026#39;, foo: foo }; // obj.foo 通过参数传递给 setTimeout setTimeout( obj.foo, 100 ); 此时 this 绑定丢失, 就会应用默认绑定，找到 window\n三、 显式绑定 显示绑定是通过 call(..) 和 apply(..) 方法，强制将 this 指向传入的对象，这种方式也叫做硬绑定\nfunction foo(something) { console.log(this.a, something); return this.a + something; } var obj = { a: 2 }; var bar = function() { return foo.apply(obj, arguments); }; var b = bar(3); console.log( b ); // 5 四、new 绑定 new 通常是使用一个函数来构造一个对象，并且该函数中所指向的 this 会绑定在这个对象上，举个栗子 🌰\nfunction foo(a) { this.a = a; } var bar = new foo(2); console.log(bar.a); // 2 使用 new 来调用 foo(..) 时，我们会构造一个新对象 bar 并把它绑定到 foo(..) 调用中的 this 上\nnew 是最后一种可以影响函数调用时 this 绑定行为的方法，我们称之为 new 绑定\n那么综上所述， React 这个情况就很好理解了\n\u0026lt;button onClick={this.handleClick.bind(this)}\u0026gt;点击\u0026lt;/button\u0026gt; this.handleClick 方法是通过回调函数传参执行的，而在 Class 语法中并没有默认做一个当前 this 绑定，所以会丢失 this 的绑定，在严格模式下，this 是 undefined\nFunction.prototype.bind() 是函数自带的绑定上下文方法， 与 call(..) 和 apply(..) 功能相似，bind(this) 之后会创建一个新的函数，并且 this 绑定在当前想要的地方\nReact 文档对此问题描述：\nYou have to be careful about the meaning of this in JSX callbacks. In JavaScript, class methods are not bound by default. If you forget to bind this.handleClick and pass it to onClick, this will be undefined when the function is actually called.\n替代 # 当然，this.handleClick.bind(this) 这种写法是有其它替代写法的，主要有两种\n第一种，可以使用箭头函数，因为箭头函数是属于静态作用域的，所以 this 会直接绑定在当前作用域\n\u0026lt;button onClick={(e) =\u0026gt; this.handleClick(e)}\u0026gt; 第二种，使用 public class fields 语法，这样就不需要每次绑定 this，可以直接使用，当然这个规范还在实验阶段，需要通过 babel进行编译执行\n","date":"2018年7月27日","externalUrl":null,"permalink":"/posts/react%E4%BA%8B%E4%BB%B6%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0bind-this-%E8%A7%A3%E6%9E%90/","section":"Posts","summary":"","title":"React事件回调函数bind(this)解析","type":"posts"},{"content":"HTTP 状态码算是很基础的知识，但是想要记住却不是那么容易的事情，根据我自己的学习和对HTTP状态码的趣(曲)解，为大家编排一个节目\nAction！ # 第 1XX 回 # 100 ： Continue（继续） # 😏 ▶️ ▶️ ▶️ 😌 # 小客：😏 你好，小服，我。。。\n小服：😌 你好！小客，想说啥，快说！\n101 ： Switching Protocols （切换协议） # 😏 ▶️ ▶️ ▶️ 😊 # 小客：😏 你好，小服，我们换 QQ 聊吧，微信传文件不方便\n小服：😊 好的，马上换\n第 2XX 回 # 200 ： OK（成功） # 😏 ▶️ ▶️ ▶️ 😊 # 小客：😏 你好，小服，我要找这个图片\n小服：😊 好的，给你\n206 ： Partial Content（部分内容） # 😏 ▶️ ▶️ ▶️ 😊 # 小客：😏 小服，把这个视频前半段先发给我\n小服：😊 好的，给你\n第 3XX 回 # 301： Moved Permanently （永久转移） # 😏 ▶️ ▶️ ▶️ 😌 # 小客：😏 你好，小服，我要找这个图片\n小服：😌 不好意思，这张图已经不在这里了，我给你个新地址，你去那找吧，以后你就按照这个地址去找吧\n302： Move temporarily （暂时转移） # 😏 ▶️ ▶️ ▶️ 😌 # 小客：😏 你好，小服，我要找这个图片\n小服：😌 不好意思，这张图暂时移走了，我给你个地址，你在那找找\n304 Not Modified（未修改） # 😏 ▶️ ▶️ ▶️ 😌 # 小客：😏 你好，小服，我要找这个图片\n小服：😌 咦？上次不是给过你了？这个图片没有更新，你就用原来的就行\n第 4XX 回 # 400 Bad Request（错误请求） # 😏 ▶️ ▶️ ▶️ 😑 # 小客：😏 你好，小服， #$%^\u0026amp;(\u0026amp;*\u0026amp;！@\u0026amp;~\n小服：😑 嗯？请说人话！\n401 Unauthorized（未授权） # 😏 ▶️ ▶️ ▶️ 🤔 # 小客：😏 你好，小服，我要找这个图片\n小服：🤔 不好意思，请出示您的身份证。。\n小客：☹️ *@$%^\u0026amp;\n403 Forbidden（拒绝访问） # 😏 ▶️ ▶️ ▶️ 🤐 # 小客：😏 你好，小服，我要找这个图片\n小服：☹️ 拒绝！\n404 Not Found（未找到） # 😏 ▶️ ▶️ ▶️ 😲 # 小客：😏 你好，小服，我要找这个图片\n小服：😲 我。。找不到了\n第 5XX 回 # 500 Internal Server Error（服务错误） # 😏 ▶️ ▶️ ▶️ 😷 # 小客： 😏 你好，小服，我要找这个图片\n小服： 😷 生病了，不想说话\n503 Service Unavailable（服务不可用） # 😏 ▶️ ▶️ ▶️ 💀 # 小客： 😏 你好，小服，我要找这个图片\n小服： 💀 卒\n504 Gateway Timeout（网关超时） # 😠 ▶️ ▶️ ▶️ 😴 # 小客：😠 小服，小服？我要找这个图片，怎么不搭理我啊？\n小服：😴\n完 # 感谢大家的观看\n字幕滚起来 ~\n\u0026hellip;\n友情出演\n😏 奸笑帝 饰 （小客）\n😊 表情帝 饰 （小服）\n\u0026hellip;\n","date":"2018年7月8日","externalUrl":null,"permalink":"/posts/%E5%B8%B8%E7%94%A8http%E7%8A%B6%E6%80%81%E7%A0%81%E8%B6%A3-%E6%9B%B2-%E8%A7%A3/","section":"Posts","summary":"","title":"常用HTTP状态码趣(曲)解","type":"posts"},{"content":"最近在使用 React 技术栈重构一个单页应用，其中有个页面是实现城市选择功能，主要是根据城市的首字母来快速跳转到相应位置，比较类似原生 APP 中的电话联系人查找功能，页面如图 主要问题 # 在上下滑动右侧 fixed 定位的元素时，页面会跟着一起滑动\n当然这个现象在开发过程中应该会经常遇到，比如弹起 modal 框时，如果 modal框的内容高度小于框高度，滑动内容也会导致页面跟着滑动， 那么在 React 中像往常一样处理\n\u0026lt;div className=\u0026#34;nonius\u0026#34; id=\u0026#34;nonius\u0026#34; onTouchStart={this.sidebarTouchStart.bind(this)} onTouchMove={this.sidebarTouchMove.bind(this)} onTouchEnd={this.sidebarTouchEnd.bind(this)} \u0026gt; 使用 React 提供的事件绑定机制，分别绑定三个 handler ，在 onTouchMove 事件中，我希望通过 preventDefault 能够阻止父级元素的滚动\nsidebarTouchMove(e) { e.preventDefault(); ... } 但实际的反馈却事与愿违，在调试中，我发现 Chrome 是有警告的，并且没有达到想要的效果 根据警告提示，找到的原因是\nAddEventListenerOptions defaults passive to false. With this change touchstart and touchmove listeners added to the document will default to passive:true (so that calls to preventDefault will be ignored).. If the value is explicitly provided in the AddEventListenerOptions it will continue having the value specified by the page. This is behind a flag starting in Chrome 54, and enabled by default in Chrome 56. See https://developers.google.com/web/updates/2017/01/scrolling-intervention\n来源: https://www.chromestatus.com/features/5093566007214080\n根据 chrome 的提示得知，是因为 Chrome 现在默认把通过在 document 上绑定的事件监听器 passive 属性默认置为 true，这样就会导致我设置的 e.preventDefault() 被忽视了。当然 Chrome 的这个做法是有道理，是为了提高页面滚动的性能，那么为了防止带来的副作用，官方考虑的很周到，给我们提供了一个 CSS 属性专门用来解决这个问题\n#fixed-div { touch-action: none; } In rare cases this change can result in unintended scrolling. This is usually easily addressed by applying a touch-action: nonestyle to the element where scrolling shouldn\u0026rsquo;t occur.\nhttps://developer.mozilla.org/zh-CN/docs/Web/CSS/touch-action\n加上了这个属性，感觉世界总算和平了，But！在 ios 系统上测试发现，这个属性 x 用没有，查了下 Can I Use 查询得知这个属性只在 Chrome 安卓等机型下是支持的，ios却用不了。既然不兼容，那只能降级处理了，为了保证良好的功能体验，感觉是还要从 passive 上做处理，说到 passive 根据 MDN文档：addEventListener 的介绍，为了提高页面滚动性能，大多浏览器都默认把 touchstart 和 touchmove 在文档元素上直接注册的这个事件监听器属性设置成 passive：true ，而通过 AddEventListener 注册的事件依然没有变化\n既然现在默认将事件 passive 的属性默认设置为 true, 那我就显式设置为 false 好了，查遍 React 的文档，也没发现事件监听器可以支持配置这个属性的，在 github 上发现这个帖子 Support Passive Event Listeners #6436 目前看依然是 open 状态的，现在不确定有没有支持这个属性\n解决方案 # 既然这样，只能单独对 touchmove 通过 AddEventListener 方法去注册事件监听了\n// 为元素添加事件监听 document.getElementById(\u0026#39;nonius\u0026#39;).addEventListener(\u0026#34;touchmove\u0026#34;, (e) =\u0026gt; { // 执行滚动回调 this.sidebarTouchMove(e) }, { passive: false // 禁止 passive 效果 }) 加上这个方法后，this.sidebarTouchMove(e) 方法中的 e.preventDefault() 方法就可以正常使用了，而且没有警告提示，问题到此就算解决了\n总结 # 总结下，这里的坑主要是 chrome 和 safari 平台的标准不统一导致的，新的标准出台，其它宿主环境不能很好的支持，当然 react 官方对这个属性的支持也比较慢，同样的前端 UI 框架 Vue 就处理的很棒 ","date":"2018年7月2日","externalUrl":null,"permalink":"/posts/react%E7%A6%81%E6%AD%A2%E9%A1%B5%E9%9D%A2%E6%BB%9A%E5%8A%A8%E8%B8%A9%E5%9D%91%E5%AE%9E%E8%B7%B5%E4%B8%8E%E6%96%B9%E6%A1%88%E6%A2%B3%E7%90%86/","section":"Posts","summary":"","title":"React禁止页面滚动踩坑实践与方案梳理","type":"posts"},{"content":"作为一枚开发人员，选择开发一款产品之前，我们肯定会进行一个技术上的选型，什么模式的开发更适合，能够更高效，或者更适合这个产品的特性？\n技术选型 # 首先，目前开发一个产品主流上大致有5种开发模式，包括 Native APP 原生应用、WebAPP 网页应用、Hybrid App 混合式开发、ReactNative、轻应用小程序，那么这几种开发模式有什么区别？开发模式是如何演进的呢？如图 首先开发一款 APP，如果注重性能，不需要过多的动态内容，可以选择原生应用来开发。如果性能要求不高，只是需要点开即用，那么 WebAPP 即可满足。如果这两种要求都必须满足，那么 Hybrid App 混合式的开发是一种折中的方法，将两者优势互补，满足大部分的需求。近几年，出现了类似 ReactNative 和小程序这种深度定制的开发模式，开发只需要写 Javascript 就可以产出性能可与原生媲美的产品，通过脚本语言面向开发者，实际跑的确是的原生组件。\n小程序优势 # 目前小程序、ReactNative 技术火热，在前端开发社区中受到开发者的青睐。那么现在是2018年，要问我开发一个 APP 首选是什么，我肯定会先考虑微信小程序，下面分析下小程序独有的一些优势。 作为开发者，我们肯定希望一个新的开发模式最好能用现在的知识去开发，而不是学习新的语言，小程序开发没有去造新的语言，使用前端开发的知识基础就能上手开发，小程序官方提供了详细的开发文档和资料，并且提供了一套开发工具供开发者使用，一直在迭代维护升级中，小程序提供了丰富的接口帮助我们快速的开发业务。减少了很多开发成本。\n作为运营人员，小程序提供了一整套的运营体系，包括多维的入口，数据分析工具，各项数据都能很好的展现给运营人员，再加上微信的流量红利，能够减少很多运营者获取用户的成本。\n小程序适合的应用场景 # 从产品角度讲，产品的呈现形式也要符合用户场景，那么小程序这种形式的 APP 适合什么类型的产品呢？小程序的一句广告语是这样说的\n###当有需要的时候，它刚好出现。\n那么，从这句话我们就能领悟出来，小程序其实适合的是不常使用且刚需的服务，或者简单点叫小频刚需，比如平常我们线下的打车、拼车、点餐、或者查违章等服务，这些需求我们平常可能一周就需要几次，没必要去下载一个 APP 在手机里睡大觉，所以小程序这种轻应用的价值就体现出来了，用完即走，不需要关心它会占用你的手机内存，因为关闭之后，小程序会自动的『消失』\n小程序的缺点 # 月有阴晴圆缺，每个事物都不是那么完美的，微信小程序也一样，那么它有什么缺点呢？我主要总结的几个方面\n受控于微信，功能限制 审核繁琐，时间相对较长 API不成熟，小程序层面的坑很多 小程序的未来 # 以上劣势其实部分都在逐渐好转，因为微信小程序一直都在迭代中，那么未来小程序的发展会怎样呢？ 从之前的PC互联网到移动互联网，现在即将迎来的是轻应用时代的互联网，各个手机厂商和一些头部 APP 都开始抢夺轻应用这块蛋糕，竞争会越来越激烈，不过我希望最终有一种标准占主导地位，这样对用户和开发者来说都是最好的。小程序的先发优势和流量优势使微信小程序的发展更加壮大，但是毕竟小程序还是在逐步成长的阶段，目前还不是很成熟，未来小程序的整套体系会越来越清晰和完善。\n","date":"2018年7月1日","externalUrl":null,"permalink":"/posts/app%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B%E4%B9%8B%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/","section":"Posts","summary":"","title":"APP技术选型之微信小程序","type":"posts"},{"content":" 酷前端 - coofend # 分享前端圈子好玩炫酷吊炸天的一切事物 😎 # 排名不分先后*\nRobby Leonardi 超级玛丽简历，见过最有创意的简历 Norse Attack Map 全球实时网络攻击图谱 pieces in pieces 使用碎片的动画绘制出30个即将灭局的物种，效果很棒 Keep Out! 基于WebGL的游戏，很赞！ WELTRADE 一个卖男装也这么有格调 Ascii Art Generator Ascii码艺术字生成器 worrydream 个人搏客-排版很吊的那种 腾讯新文创大会H5 canvas video Through The Dark 一位歌手父亲写个白血病儿子的歌，用webGL展现 Ancient Earth globe 一个记录数亿年间地球面貌变迁的网站 threejs tweenjs Carbon 将代码片段美化并生成图片的工具 Radio Garden (需翻墙)可以在谷歌地球上收听全世界的广播电台 Hyper 基于前端桌面应用框架 electron 的命令行工具，跨平台 electron giojs 基于 Three.js 的地球 3D 数据可视化库 Three.js 欢迎同道中人提 PR 或 Issues 一起分享炫酷的前端事物 github项目地址： https://github.com/w3cay/coofend\n","date":"2018年6月24日","externalUrl":null,"permalink":"/posts/%E7%82%AB%E9%85%B7%E5%A5%BD%E7%8E%A9%E5%89%8D%E7%AB%AF%E8%B5%84%E6%BA%90%E5%A4%A7%E7%9B%98%E7%82%B9-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/","section":"Posts","summary":"","title":"炫酷好玩前端资源大盘点(持续更新)","type":"posts"},{"content":"作为一名 web 开发工程师，开发一个网页很简单，但是想开发出一个性能强加载速度快的网页却不是那么简单，涉及到的方面很多，比如服务端的响应，客户端加载、渲染，开发者代码的组织等等，很多因素都可能使你的页面性能不佳，今天根据我最近的学习，着重总结一下客户端渲染相关的优化建议和相关原理。\n浏览器的渲染过程 # 浏览器的渲染过程非常的复杂，如果想讲清楚大概可以写一本书，比如《WebKit技术内幕》，但是长话短说，把浏览器的渲染过程总结一下可以分为下面几个步骤：\nDOM Tree生成：通过网络加载到浏览器的本地，经过HTML解析器处理，生成 DOM Tree CSS 规则生成：CSS 样式表经过 CSS 解析器的处理计算，生成最终的 CSS 规则 javascipt的解析和执行：由于浏览器渲染是单线程的，javascript 的解析执行是在浏览器解析 HTML 过程中进行的，包括词法分析、抽象语法树、字节码以及本地代码的生成等过程 布局 Layout生成： DOM Tree 和 CSS ruler 经过一顿糅合的布局样式计算，形成 renderTree 绘制: 根据计算得来的renderTree，绘制每个元素的大小、边框、位置、阴影等效果，绘制的过程是分层进行的，比如图片和一些 Transform 效果都在不同的层进行绘制 合并：将绘制的各层进行合并渲染，最终体现在屏幕像素中 那么在这几个步骤中，我们怎样优化才能使性能有一个更好的提升呢？\n性能优化建议 # 在页面渲染过程中，1到3的过程可能只执行一次，但是后面的4到6至少执行一次，所以为了更好的性能，应尽量减少后面的渲染触发\n在 DOM Tree 生成阶段，我们应尽量减少 DOM 的层级 在 CSS 规则生成阶段，同理，为了更快的解析和计算，尽量简化规则样式\n在 JavaScript 解析执行阶段，除了通过优化代码的编写，执行时机，对于计算量庞大的模块，应放在 Web Worker 中执行，避免因 javascript 的执行而导致 UI 渲染的卡顿与延迟\n在布局阶段，除了上面提到的优化，尽量将 JavaScript 代码置于 body 标签底部，除了可以减少页面渲染的卡顿，还可以减少页面的不必要回流计算\n在绘制合成阶段，我们要将频繁变动的组件或者动画提升至合成层进行渲染，并且动画尽量使用 css 的 transform 进行描述，而不是对元素的大小、位置属性进行重新赋值，导致多次回流与重绘，使用transform的原理是将这部分的渲染交给 GPU 来进行处理，极大的增强了渲染性能。\n以上就是我对渲染相关的优化总结，上面的优化可以让浏览器更『轻松』的处理我们的 UI 效果，当然 web 的优化还有很多方面，单单是对浏览器内部的优化还不足以让用户有很大的感知，所以全方位的实际问题定位才是解决 web 体验的良方。\n","date":"2018年6月23日","externalUrl":null,"permalink":"/posts/web%E6%B8%B2%E6%9F%93%E5%8F%8A%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/","section":"Posts","summary":"","title":"Web渲染及性能优化","type":"posts"},{"content":"春节过完，现在调整心态，可以开始新一年的计划和工作了。坐下沉思了半天，感叹2017年过的真的很快，并且很难想2017年做了什么技术上的突破性的东西。\n这一年总结起来可以说大部分时间都放在了公司的业务上，而且是很繁忙的业务。作为程序猿我不反感做业务，但是如果是机械性的业务，做多了，我就会心慌，总想有什么自动化的办法能够避免重复劳动，这也可以叫『懒』\n具体到细节，这一年也接触了一些我之前没接触过的东西或者接触很少的技术，比如小程序、React、工具和库的建设等。\n这些技术其实在大体上都很好理解，具体到开发其实就是面向 API 编程，React生态我现在了解的还不是很多，因为之前大多使用VUE的一套东西，技术底层大差不差，我认为React优秀在于可以进行全端的客户端开发，而 Vue 现在看还不是很成熟，主要是生态建设上。\n小程序也是我新接触的一套开发模式，得益于微信的流量入口，目前来看小程序将会有一个繁荣期，并且微信的重心逐渐在往小程序倾斜。这一年总共开发了四款小程序，从开发者的角度看，坑还是很多的，大多是兼容问题和API的BUG，如果没有做过小程序，第一次开发会感觉有点不适应，相对H5开发，小程序能提供更多的API，并封装了一套小程序的语言和规范，总体感觉对开发者的友好程度逐渐增强。\n这一年断断续续的做了一些团队工具上的工具，我的一个目的就是想让团队能够更有效率的开发出可靠地产品。因为自己业务在身的原因，开发进度一度被搁置，导致项目难产或者没有很好的在团队推广开来，所以目前看还是没有精力去做这些事情，希望今年可以留点时间来完成此事。\n新年伊始，给自己定几个技术上的工作内容\n继续增强自身基础底层知识，提高基础封装能力 新技术的学习与研究，包括小程序、小游戏、TypeScript、PWA、WebAssembly、WebVR等技术 继续调研学习前端架构，提高效率，包括开发、调试、发布、测试、监控等流程 继续经营自己的技术博客，总结项目实践，并做几次分享。PS:断更其实我也很无奈 希望2018年自己的前端开发能力能上升一个台阶！😉\n","date":"2018年2月22日","externalUrl":null,"permalink":"/posts/%E6%88%91%E7%9A%842017%E5%B9%B4%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93%E4%B8%8E%E8%A7%84%E5%88%92/","section":"Posts","summary":"","title":"我的2017年前端技术总结与规划","type":"posts"},{"content":"这可能会存在一些争议，据我所知 async/await 这个特性受到很多开发者的青睐。对于不熟悉的同学，简单讲，其实它就是一种让开发者处理 Promise 更漂亮点儿的原生语法。\nasync/await 写法：\nasync function doSomethingCool() { let someValue = await getSomePromise(); console.log(someValue + \u0026#39;!!!\u0026#39;); } Promise 写法：\nfunction doSomethingCool() { getSomePromise.then(someValue =\u0026gt; someValue + \u0026#39;!!!\u0026#39;); } 在上面的例子中，假定 getSomePromise 就是一个能够返回 Promise 的函数。\n回忆过去 # 多年以前， C# 迎来了 async、await 特性，让很多人兴奋不已，并号称『让异步编程更简单易懂』（至少我的同事们是这样认为的），因为它的『简洁』导致很多人喜欢。现在 async、await 特性在 Javascript 也落地了，我也听到了同样的声音。但是我对此带来的好处心存疑虑。\n优势 # 之前需要很多函数组成的功能，现在只需要一个函数。从视觉上就能感觉到复杂度降低了，之前需要 2n 个大括号的代码，现在只需要2个足以。无论如何，会让人感觉更简单些。 语法后面不用再加 then 链式回调函数。对于大多数人来说，Promise 和函数式编程有个巨大的转变就是链式回调函数。说实话，有些人很难处理这些回调。 try/catch 使 async 语法的异常捕获更加好用。这可能是 async、await 带来我最喜欢的特性。使得 Promise 的异常错误处理像『常规 javascript』一样，例如： let bad = () =\u0026gt; Promise.reject(\u0026#39;bad\u0026#39;); async function coolWay() { try { let result = await bad(); doSomething(result); } catch (err) { console.error(\u0026#39;An error!\u0026#39;); } } 对比\nlet bad = () =\u0026gt; Promise.reject(\u0026#39;bad\u0026#39;); function lameOldWay() { bad() .then(doSomething) .then(null, err =\u0026gt; console.error(\u0026#39;An error!\u0026#39;)); } 在我看来，第一个示例很明显的表示了 catch 块会捕获 bad() 或 doSomething() 的任何异常，然而在第二个示例中，除非你非常熟悉 Promise 的语法，不然你会很难发现在哪里捕获异常。尽管如此，这在一些人眼里并不算一个很大的问题。\n劣势 # 之前需要很多函数组成的功能，现在只需要一个函数。（你可能注意到这个在上面优势提到过）当多个函数合并成一个函数之后，会很难区分函数的事件。然而当函数分开使用的时候，会清晰的看到单个函数触发的事件。 经过编译的代码臃肿并丑陋。在当前这个时期，如果你想使用 async/await，你就需要通过 Babel 来进行编译才能执行。问题就是，当你写好了几行代码，编译过后代码将会是几倍的代码量。 用或者不用 # 你可以同时使用基于链式调用的 Promise ，也可以使用 async/await，这都并没有什么。我不确定哪个更适合你，但是只要适应场景并且能使代码更可读，你就用吧！\n总结 # 最好去深入了解 async/await，我敢打赌在大部分的应用场景中你并不需要区分到底哪种方案语法更好，最重要的是去权衡哪个写法更能让你的代码更『好看』，如果两者都 ok ，那么我个人推荐使用 Promise 的链式调用的方法，因为它更简单直接，性能更好，编译的出的代码更少。然而，强大的 async/await 能让你更加自然的使用 try/catch。\n翻译原文: 《 async/await: It’s Good and Bad 》 —— Ben Lesh ","date":"2017年8月5日","externalUrl":null,"permalink":"/posts/asyncawait%E7%9A%84%E4%BC%98%E5%8A%BF%E4%B8%8E%E7%BC%BA%E6%86%BE%E8%AF%91/","section":"Posts","summary":"","title":"'Async/Await的优势与缺憾[译]'","type":"posts"},{"content":"TypeScipt 中的类型检查是 Javascipt 所缺少的，当考虑到项目的可靠性时，这个特性是必不可少的，目前的可实行方案有 TypeScipt 和 Flow 可供选择，下面和 ES6 做下比较和分析\n方案比较 # 方案 简介 生态支持 学习成本 迁移成本 使用收益 ES6 是一门弱类型，面向对象（基于原型）的高级编程语言 目前部分 ES6 特性在现代浏览器得到支持，通过 Babel 转译为 ES5 可使用大部分特性 成本较低 目前项目已配置 ES6 编译环境，成本基本为零 语法相比之前的版本更加简洁和高效 TypeScript TypeScript是一种由微软开发的自由和开源的编程语言。它是JavaScript的一个严格超集，并添加了可选的静态类型和基于类的面向对象编程 TypeScript 是微软的一个开源项目，目前最新版本 2.3，GitHub Star 数达到 22761,工具链上与 Gulp, Webpack 都有很好地支持,全平台 Typescript 的学习成本比较高，他包含了泛型、接口等很多 java、C# 的概念 由于 TypeScript 是一整套的方案，所以老项目迁移困难，新项目则成本较低 因为 TS 提供了很多强类型语言的功能，所以可以使得代码更健壮，编译后的代码也是针对 V8 等 js 引擎优化过的，所以执行效率也不会太慢，通过编辑器的支持，可使开发调试更有效率 Flow 由 FaceBook 开发的一套 JavaScript 类型检查工具 Flow 是FaceBook 的一个开源项目，目前最新版本 0.47.0 ，GitHub Star 数达到 12122,工具链上与 Gulp, Webpack 都有很好地支持, 全平台 Flow 的学习成本相比较 TypeScript 较低 Flow 的可配置性和灵活度较高，可选择单个文件或整个项目的类型检查处理，并且基于和 Babel 搭配使用，所以项目迁移成本较低 同 TypeScipt 结论 # 对于当前项目，从平缓迁移的角度看，Flow 更符合当前的需求。而 Typescript 更适合于新项目或者大型的应用项目，可在团队内部项目试用，进行踩坑沉淀，待整个生态摸索的较为成熟再逐步应用到业务并在团队推广，并同时统一团队编码风格，提高团队协作效率。\n","date":"2017年6月10日","externalUrl":null,"permalink":"/posts/javascript-%E9%9D%99%E6%80%81%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5%E6%96%B9%E6%A1%88/","section":"Posts","summary":"","title":"' JavaScript 静态类型检查方案'","type":"posts"},{"content":"眨眼间2017年已经过了两个月，之前本来想着写个2016的总结，但是不知道什么原因给忘掉了，可能因为年前忙着公司的需求了,也可能并没有想好怎么总结，总之就是搁置过去了。今天想想总结这个事情还是非常有必要的，有总结才能有成长，不然2016年可能过得就是个假年。顺便吐槽一下，元旦前的一段时间各种总结文章铺天盖地，看的我眼花缭乱。\n我自认为，2016年是我技术生涯的一个关键时期，从2015年实习到2016的转正，我的技术成长主要就在于2016年这一年，从刚出校园的职场小白，到适应了公司环境的『小油条』，在完成公司的需求方面也变得越来越轻松，实习时期的紧绷感逐渐缓和了许多，也可能是自己技术自信的建立 😏\n一段时间的工作使我认识到开发效率的重要性，这一年我逐步认识并实现了前端开发的组件化和工程化，这里不得不提尤大的 Vuejs，还有令人既爱又恨的 Webpack, 两者的配合很好地实现了组件化和工程化。2016年前端界欣欣向荣，各种框架层出不穷。然而，这么多框架选择了 Vuejs 就是因为它是一个渐进式的框架，可以很轻松的与现有的老项目组合，并且 Vue的学习成本相对较低，便于在团队铺开。在构建工具方面，从一开始使用 gulp 到 gulp + Webpack，再到 WebPack， 使得 Webpack变得异常重要，但是这个转变的过程也是很麻烦的，就是在于 Webpack 繁琐的配置和低下的执行效率，在工程化方面也是浪费了不少时间。\n为了更好的实现开发到部署的完美体验，我开始关注持续集成（CI）和 Docker 相关的技术，使得产品的生产就像是一个流水线。通过在自己的开源项目中实验性的试用，确实提升了效率，优化了生产过程。\n在产品部署完成之后，我意识到一个重要的问题，如果我的代码在线上环境出现了报错我怎么才能知道呢？后端开发都有成熟的日志报错机制，但是前端并没有监控错误的机制，后来通过自己的研究和实践逐步在公司的项目上部署了 Sentry 监控，完成了对前端代码的报错监控，很好地避免了一些由于不同环境所造成的错误，确保了产品质量。详情请见我之前的文章\n前端技术一直都在不断的更新，为了保证自己不掉队，需要不断的学习和实践。\n面对前端框架漫天飞的这种现象，我逐渐意识到，追逐框架并不是长久之计，把自己的内功练好才是最重要，所谓的内功就是前端的基础知识以及计算机科学相关的基础知识，虽然基础但是精通之后才能以不变应万变，轻松应对各种前端工具的变化。\n在接下来的时间里不但要把基础知识强化和巩固，还要去拥抱变化，去接触更新的技术，包括 ES2017、Progressive Web Apps、WebAssembly、Weex、WebVR、WebComponents 等技术。PS: 看来是要统一大前端了。Web 这个平台越来越强大，应用领域越来越广，也是我当初选择前端开发的初衷。\n前端的路很长，戒骄戒躁，勿忘初心。😎\n","date":"2017年2月6日","externalUrl":null,"permalink":"/posts/%E6%96%B0%E5%B9%B4%E5%BC%80%E7%AF%87%E6%8A%80%E6%9C%AF%E9%98%B6%E6%AE%B5%E6%80%A7%E6%80%BB%E7%BB%93%E4%B8%8E%E6%80%9D%E8%80%83/","section":"Posts","summary":"","title":"新年开篇：技术阶段性总结与思考","type":"posts"},{"content":"","date":"2016年12月28日","externalUrl":null,"permalink":"/categories/%E4%B8%AA%E4%BA%BA%E6%88%90%E9%95%BF/","section":"Categories","summary":"","title":"个人成长","type":"categories"},{"content":" 吾生也有涯，而知也无涯。以有涯随无涯，殆己 —— 《庄子 养生主》\n作为一名程序员，每天都需要给自己充电学习，才能保持自己的不断成长。然而盲目的学习肯定是浪费时间的，需要掌握一定的方法和技巧才能事半功倍。在信息大爆炸的时代，知识是无穷无尽的。\n所谓学而不思则罔，思而不学则殆，能高效和理性的甄别自己需要的知识学习并吸收它们，之后建立自己的知识体系，是非常重要的。学习的目的是为了看清这个世界，更好的在这个世界生活，不是要把自己学成一块移动硬盘，用来存储大量的垃圾文件。\n学习的方法非常重要，以下是我的技术学习方案，鄙人并不是什么学霸，所以仅供参考\n我的知识学习过程分为三个阶段：收集，归总，汲取\n收集 # 收集的过程从上图中可以看出，主要有三个方面：\n内容聚合 # 顾名思义，内容聚合就是一个信息和知识聚集的平台，减小了知识获取的难度，我目前主要使用的内容聚合平台主要有，深蓝阅读（RSS），微博，知乎，Github。\nRSS 是一个虽然很老的技术但是真的非常实用的功能，大多数的网站和博客都支持 RSS 订阅，目前互联网上很多技术文章的聚合平台，比如掘金，开发者头条等等，但这些平台的技术文章都是别人发布的，别人发布什么或者什么最火，上面就会有什么，它不能根据你的喜好来进行技术文章的获取，同质化的文章很多。而 RSS 就可以订阅你想要的技术文章和新闻，对于聚合的范围更可控。其实这两个形式没有绝对的好坏，就好比一个是电视，一个是互联网，电视机的内容是电视台播放什么内容你就看什么，而互联网的内容需要你自己去查询和订阅。但后者更适合于知道自己需要什么的人。\n微博也是聚合平台，里面可以订阅社区活跃的开发者，同时还可以订阅其它非技术的博主。微博跟其他新闻应用（其实不是新闻应用）不同，最大的特点是它的信息是实时性的，可以更快的监测到技术的最新动向，所以，我把这个聚合平台当做是我的技术新闻信息的主要获取平台。但是微博的内容都是非常简短的，信息更详细的内容或有所欠缺。幸运的是，知乎弥补了这个缺陷。\n知乎也是我的主要技术信息和知识的获取平台，不仅可以从诸多问答中学习到很多技术上的知识和行业的动向，更重要的是，因为知乎是个讨（撕）论（B）平台，事情都是越辩越明，可以从大量的讨论中获取到很多书本上学习不到的知识，让你学会更客观的看待技术。\nGithub 也是一个聚合平台和社交平台，正所谓『世界上最大的同性交友网站』，你可以关注一些技术大牛的账号，从技术大牛的 star ,forked 和 comment 中可以发现很多很棒的项目，学习别人的项目思路和代码，睁眼看世界。\n项目实践 # 项目实践是程序员很重要的经验和技巧学习的获取方式，纸上谈兵永远都不能把程序写好，实践才是检验真理的唯一途径,所以，不论是个人项目还是公司项目，都是个人学习的最好方法，可能一开始什么都不会，但是在开发的过程中，你通过查阅资料解决问题，比你直接看资料学习效率和成果都要高很多。\n技术书籍 # 以上的知识获取过程都有些『肤浅』，通过聚合平台和项目实践得来的知识只是解决问题的方法和经验，甚至很多信息都是从书中所摘，那么如果想知道为什么这样解决问题，为什么这样解决问题更好，还是要看书。看书可以使自己的知识更加的成体系，更深刻的理解自己所做的事情。\n通过以上几个途径使我能获取到大多数的技术知识了，但是知识那么多，怎么梳理这些知识呢？\n归总 # 书签收藏 # 每天通过聚合平台获取到的知识是大量的，有的是需要了解的知识，有些事需要你以后用到的知识，所以一般把我未来会用到的知识（网页），我都会把他收藏到 Chrome 书签中，Chrome 有个非常棒的功能，当你在地址栏搜索时，搜索框的备选项中会匹配你之前收藏过的书签标题，可以不用再去通过 Google 寻找了。有个小技巧，保存书签的时候可以复制网页正文当做标题，这样下次搜索时只要匹配到这篇文章的一个词就会显示在备选中。如果你喜欢使用 Pocket，印象笔记等软件进行收藏，你会发现，到最后堆成山你都不会去看上一眼，为此印象笔记有个插件『剪藏』提供了在搜索结果中展示笔记中匹配到的笔记，但是体验过后发现中文的匹配太差劲了，而且展现的结果是在搜索结果页，不能展现在搜索框的备选项中。\n技术笔记 # 知识都是很零碎的，想把知识都归纳起来，有些人建议印象笔记或者为知笔记，但是当我体验过很多笔记记录软件后，感觉每次记录之后整理笔记是个很烦的事，以记事本为单位还是以单个笔记为单位，还是用标签。最后整理完，很难形成一个很好地结构体系，所以我后来用了 Workflowy 这个工具 可以更方便的定义你的知识结构，结构上下级可以随意调整，无限的分类，事实上，很多知识都是这样的，有时层级会很深，如果使用普通的笔记，很难控制和体现这种关系。这款软件的缺点是类似 Markdown 但是不支持 Markdown。只适合用来记录纯文本的知识。Chrome 有插件提供支持 Markdown 相关的功能，但是我体验之后感觉一般。还有个问题是国内的访问会比较慢，不过国内也有个类似的软件叫『幕布』，目前在用，特点是速度快并且支持预览脑图，可以通过图的形式查看你知识体系。\n博客总结 # 博客可以写自己的项目经验、知识总结、一些想法等等，写博客是对某个专题深层次研究的过程。在上学的时候，每当给别人讲解题目的时候，会发现你对这道题目会有更深的理解，写博客也是，你在写博客的同时，对你写的东西会有更深刻的印象，所以，有时候我记不住的知识我都会通过写文章发博客的形式让自己记住。通过写博客，你可以总结旧的的知识，同时也可以衍生出你的观点。更重要的是写博客也是一个知识分享的过程。\n汲取 # 通过结构化笔记和博客的总结之后，你会在这个过程中形成自己的知识体系，对知识的理解更加的深刻。我们学习的目的是为了在项目中应用，所以通过学得的知识应用在项目中，会提升你的项目开发能力。而后，你在项目中的经验又会通过总结，形成你知识体系的一部分，这样就形成了知识的正循环。\n以上就是我个人的知识管理方案和对学习的理解，因为每个人所处的环境和学习方法不同，所以我所描述的东西不完全『正确』，仅供参考。如果以上赘述对你有帮助，深表荣幸。🐶\n","date":"2016年12月28日","externalUrl":null,"permalink":"/posts/%E4%B8%AA%E4%BA%BA%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86%E6%96%B9%E6%A1%88/","section":"Posts","summary":"","title":"个人技术知识管理方案","type":"posts"},{"content":"","date":"2016年12月28日","externalUrl":null,"permalink":"/tags/%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/","section":"Tags","summary":"","title":"学习方法","type":"tags"},{"content":"","date":"2016年12月28日","externalUrl":null,"permalink":"/tags/%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/","section":"Tags","summary":"","title":"工具推荐","type":"tags"},{"content":"","date":"2016年12月28日","externalUrl":null,"permalink":"/tags/%E6%8A%80%E6%9C%AF%E6%88%90%E9%95%BF/","section":"Tags","summary":"","title":"技术成长","type":"tags"},{"content":"","date":"2016年12月28日","externalUrl":null,"permalink":"/tags/%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86/","section":"Tags","summary":"","title":"知识管理","type":"tags"},{"content":"今天注意到这样一个问题❓\n下面代码背景色仍然是灰色，所以id权重为100，class权重为10，是不正确的吧？\n\u0026lt;p id=\u0026#34;testId\u0026#34; class=\u0026#34;class1 class2 class3 class4 class5 class6 class7 class8 class9 class10 class11\u0026#34;\u0026gt; \u0026lt;/p\u0026gt; #testId { background-color: grey; } .class1.class2.class3.class4.class5.class6.class7.class8.class9.class10.class11 { background-color: red; } 效果 刚看到这个问题，自己也有点蒙，不是说 Id 选择器权重代表 100 ，class 为 10 吗，为什么还是灰色？当我试了一下才发现，确实是这样的。后来我把代码改成这样\n\u0026lt;div class=\u0026#34;class1\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;class2\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;class3\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;class4\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;class5\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;class6\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;class7\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;class8\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;class9\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;class10\u0026#34;\u0026gt; \u0026lt;div id=\u0026#34;testId\u0026#34; class=\u0026#34;class11\u0026#34;\u0026gt; 测试 \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; #testId { background-color: grey; } .class1 .class2 .class3 .class4 .class5 .class6 .class7 .class8 .class9 .class10 .class11 { background-color: red; } 效果没变 好奇心驱使我找资料查了下，才恍然大悟，原来样式选择器的权重值没有 10 进制这个规则，我猜测应该是我们把规范中的 0，0，1，0 理解成了 0010，形成了思维定式 ，使我们误以为这是可以满 10 进 1 的。资料上是这样说的：\nUnfortunately, specificity is not calculated in base 10 but a high, unspecified, base number. This is to ensure that a highly specific selector, such as an ID selector, is never overridden by lots of less specific selectors, such as type selectors. However, if you have fewer than 10 selectors in a specific selector, you can calculate specificity in base 10 for simplicity’s sake.\n参考《Css.Mastery.Advanced.Web.Standards.Solutions.(2nd.Edition)》\n这个问题使我意识到，在平常学习的时候，还是要多注重细节问题，书读百遍其义自见。\n","date":"2016年11月28日","externalUrl":null,"permalink":"/posts/%E5%85%B3%E4%BA%8Ecss%E9%80%89%E6%8B%A9%E5%99%A8%E6%9D%83%E9%87%8D%E8%AE%A1%E7%AE%97%E7%9A%84%E7%96%91%E6%83%91/","section":"Posts","summary":"","title":"关于CSS选择器权重计算的疑惑","type":"posts"},{"content":" 引言 # 每天早上到公司后，我都会先翻阅RSS上订阅的技术文章，前几天在看文章的时候突然注意到这样一句话\n程序开发三板斧：功能、测试和监控。\n看到这里我停了一下，仔细琢磨，发现这句话总结的非常到位和精辟。作为程序员，可能大部分人关注的只是功能需求的开发，但并不关心程序的测试和监控方面的问题，往往容易被忽略的问题有时候却非常的重要。看完文章后我就开始着手研究前端测试和监控方面的东西。以下是我的调研总结：\n前端测试 # 我所理解的前端测试主要分为单元测试、UI测试、性能测试。\n单元测试主要是对方法和类库的测试，单元测试最长用的两个库是 Mocha 和 Jasmine,通过写测试脚本来对小模块的代码进行测试，具体教程请参考 测试框架 Mocha 实例教程 —— 阮一峰。单元测试存在个弊端，就是你需要去写大量的脚本去跑测试用例，而且如果需求变动，你的代码逻辑就会变动，所以你的测试脚本也要做相应的维护。如果是在大公司，人力充足有专门测试人员的情况下，以上的问题应该不是问题，但是像大多数人所处的小公司，业务有时候可能都开发不完，更没时间维护测试脚本了。所以做单元测试需要消耗一定精力，量力而行。\nUI测试方面包括对页面样式的测试，比如在各种浏览器下的显示效果有没有出现异常等等，还包括对交互的测试，比如点击按钮是否会有相应的反馈等等。性能测试主要是对网页加载速度的检测，包括不同网络环境不同设备的情况下加载情况的的测试，以上两个方面的测试推荐大名鼎鼎的测试工具 Phantomjs 这个工具是一个无头浏览器，对于web测试、界面、网络捕获、页面自动化访问等等方面都很强大。基于 Phantomjs 还有相关的 PhantomCSS 帮助做像素的比对测试，和 PhantomFlow 来进行操作对比测试。由于没有太多实践，这里略过。\n前端测试方面有的公司会有专门的部门进行测试，但是像我所处的创业公司很少会有专门的测试人员，在测试方面本人的实践经验较少，主要还是在开发中不断的进行人工测试来保证产品质量。但是有时候开发人员的人工测试并不能把所有的 BUG 都抓出来，即使用户发现了 BUG ,又有多少愿意提出 BUG 的呢？所以一个稳定的系统，监控这个环节是非常重要的。\n前端监控 # 监控在提高产品稳定和质量方面有很重要的作用。关于前端监控的重要性，可以先看看这篇文章 不可忽视的前端监控 —— 张鑫\n在前端监控方面，本人在公司的项目上实验性的部署了 Sentry ，这是一个跨平台的错误日志收集系统，不只是Web前端可以使用，其他开发也能使用。引入项目后能够监听到 Web 页面上的 JavaScript 错误，通过邮件及时的通知开发人员进行 Bug 追踪。这个项目是开源项目，可以自己搭建公司的日志管理系统，也可以使用 Sentry 的服务。\n安装方法 # 通过CDN方法引入\n\u0026lt;script src=\u0026#34;jquery.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.ravenjs.com/3.8.0/raven.min.js\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt;Raven.config(\u0026#39;你的DSN（在后台获取）\u0026#39;).install();\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;app.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 当然也可以通过 NPM 和 ES6 的语法引入\nimport Raven from \u0026#39;raven-js\u0026#39;; Raven .config(\u0026#39;你的DSN（在后台获取）\u0026#39;) .install(); 如何使用 # 当你的 JavaScript 代码出现语法错误时，Sentry 会自动帮你上报代码错误。也可以自己将发送报错代码放在 try..catch 块中\ntry { doSomething(a[0]) } catch(e) { Raven.captureException(e) } 也可以直接抛出错误或者是个打点信息\nthrow new Error(\u0026#39;信息\u0026#39;) // 这样写比较好 throw \u0026#39;信息\u0026#39; // 不建议这样写 同时 API 提供错误信息的配置，包括错误等级、注释 log 、 tag 、黑白名单等等，方便错误的追踪统计。\nRaven.config(\u0026#39;你的DSN（在后台获取）\u0026#39;, { level: \u0026#39;info\u0026#39; // 可以是 \u0026#39;info\u0026#39;、 \u0026#39;warning\u0026#39;、或者是 \u0026#39;error\u0026#39; 其中一个 logger: \u0026#39;my-logger\u0026#39;, //log注释类型 environment: \u0026#39;production\u0026#39;, //产品环境 release: \u0026#39;721e41770371db95eee98ca2707686226b993eda\u0026#39;, // 当前代码版本 whitelistUrls: [ /disqus\\.com/, /getsentry\\.com/ ], ignoreErrors: [ \u0026#39;fb_xd_fragment\u0026#39;, /ReferenceError:.*/ ], includePaths: [ /https?:\\/\\/(www\\.)?getsentry\\.com/ ] }).install(); 如果你的 JavaScript 代码是经过代码打包工具压缩的代码，比如 Webpack ，出现错误的时候，会出现提示错误在第一行好几百列的情况，导致代码追踪困难，代码压缩工具一般可以生成 SourceMap 文件，Sentry 默认会在当前 JavaScript 资源路径寻找 SourceMap 文件，如果能请求到，它会解析出源代码，方面追踪错误，但是这会有安全的隐患，就是其他人也能查看并调试你的代码。基于这个问题 Sentry 提供了 SourceMap 上传服务，将产生的 SourceMap 文件通过 API 或者 CLI 进行上传，既解决了错误代码追踪问题又解决了安全问题。\n在我们公司项目部署了 Sentry 后，发现一个不足之处，就是没有监测到资源加载错误，所以本人在项目页面中公共头部加入了监听 onerror 事件代码，当资源加载失败时发送错误 Log 给 Sentry ,通过对资源加载情况进行监视，能够及时发现和统计资源的问题。\n// Record Resources load Errors window.addEventListener(\u0026#39;error\u0026#39;, e =\u0026gt; { if (e.target.src \u0026amp;\u0026amp; Pro) { Log(`src load error at ${e.target.src}`, { logger: \u0026#39;Resources\u0026#39;, }); } }, true); 以上只是调研实践的一点总结，后续会着重研究一下前端自动化测试方面的东西，虽然这个坑很深。\n延伸阅读：\nhttp://taobaofed.org/blog/2015/12/10/frontend-test-platform/\nhttp://fex.baidu.com/blog/2015/07/front-end-test/\nhttp://www.alloyteam.com/2014/03/front-end-data-monitoring/\nhttp://fex.baidu.com/blog/2014/05/build-performance-monitor-in-7-days/\nhttps://zhuanlan.zhihu.com/p/23310438\nhttps://www.zhihu.com/question/29953354/answer/128837124\n","date":"2016年11月8日","externalUrl":null,"permalink":"/posts/web%E5%89%8D%E7%AB%AF%E6%B5%8B%E8%AF%95%E5%92%8C%E7%9B%91%E6%8E%A7%E7%9A%84%E6%8E%A2%E7%B4%A2%E5%92%8C%E5%AE%9E%E8%B7%B5/","section":"Posts","summary":"","title":"Web前端测试和监控的探索和实践","type":"posts"},{"content":"最近突然想做一个聊天室项目，根据自己学习情况和项目特点，最终决定选择使用 Express、Vue 和 Webpack 来进行项目的搭建。顺便吐槽一下，现在想徒手搭一个前端项目真的比后端环境都难配置，下面记录我的搭建过程和踩坑之路。\n首先贴上项目地址 https://github.com/w3cay/ChatGroup\n项目托管在Github上，除了添加一些说明文档和版权信息外，首先进 行 Git 的相关配置，在项目的根目录添加了 .gitgnore 文件，忽略一些不需要提交变化的文件，主要是 node 生产环境产生的一些文件。 接着，添加一下编辑器的配置，这个主要是为了防止不同编辑器之间的差异，如果是一个人进行开发还好，但是如果需要协作开发的话最好配置一下。在根目录我还添加了一个 .gitattributes 文件，主要是优化 git diff的体验，忽略编译文件的变化，不然满屏的压缩代码。具体配置请参考 http://www.jianshu.com/p/8ec1b32f2e13\n接下来，初始化node环境，使用 npm init 创建一个 package.json 文件，在这里进行node的包管理，然后开始安装部署 Express ,通过 Express 生成器生成项目的基本结构。\n安装Express生成器\n$ npm install express-generator -g 生成示例项目并将示例项目和当前项目目录进行整合\n$ express demo 进入项目，安装依赖\n$ cd Chatgroup $ npm install 初次运行项目,通过 localhost:3000 来进行访问\n$ DEBUG=Chatgroup:* npm start 基本结构定好了，但是发现很不爽的事情，node服务每次修改代码，并不能生效，每次都需要进行重启服务器。所有后来又加上了 nodemon 这个插件，可以在每次修改服务端代码的时候，自动重启服务器，节省了时间，但是感觉体验还不是很好，启动服务器中间还是有间隙的，不能马上生效，所以感觉还是写PHP爽啊！\n安装了nodemon之后，启动Express服务器的命令变为\n$ DEBUG=ChatGroup:* cross-env NODE_ENV=dev nodemon -i src ./bin/www 其中 cross-env 的作用是解决跨平台设置NODE_ENV的问题\n到此，服务端的环境配好了，接下来我开始配置前端的工作流 ，前端开发使用 Vue 框架，JavaScript 采用 es6 语法，Css 使用 scss 语法预编译，使用 webpack 处理语法编译，并且打包。为了解放F5,我在 webpack 中配置了 BrowserSync 插件，通过 localhost:2333 进行访问，每次前端代码的改动都会刷新浏览器，这里没有使用webpack的热更新，以后再加上，配置详情直接访问GitHub查看。\nplugins: [ new webpack.optimize.OccurenceOrderPlugin(), // new webpack.HotModuleReplacementPlugin(), new webpack.NoErrorsPlugin(), new webpack.optimize.UglifyJsPlugin({ compress: { warnings: false } }), new ExtractTextPlugin(\u0026#39;[name].css\u0026#39;), new BrowserSyncPlugin({ // browse to http://localhost:3000/ during development, // ./public directory is being served host: \u0026#39;localhost\u0026#39;, port: 2333, proxy: \u0026#39;http://localhost:3000/\u0026#39; }, // plugin options { // prevent BrowserSync from reloading the page // and let Webpack Dev Server take care of this reload: true } ) ] 到此，整个项目的前后端环境搭建的差不多了，数据库方面会采用 MongoDB,具体的配置这里就不赘述了，本篇文章不算是严谨的教程，项目并没有搭建的非常完美，此篇文章只是作为我的开发笔记，如有错误欢迎评论指出。☕️\n","date":"2016年9月20日","externalUrl":null,"permalink":"/posts/%E5%9F%BA%E4%BA%8Eexpress-vue-webpack%E7%9A%84%E8%81%8A%E5%A4%A9%E5%AE%A4%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/","section":"Posts","summary":"","title":"基于Express+Vue+Webpack的聊天室项目搭建","type":"posts"},{"content":"Git版本控制器（Github）在我的实际开发过程中起到很重要的作用，它使开发过程更有效率。通过Git可以记录项目中代码的每一次变化，并且可以“穿越时空”回到过去的任何状态。我在开发中主要使用Git的命令行提交每次的变化和克隆线上项目，自我感觉Git命令非常重要,所以今天总结一下我平常使用的一些Git命令。\n从现有仓库克隆项目到你的工作空间 $ git clone [url] 要确定哪些文件当前处于什么状态： $ git status 跟踪新文件，要跟踪 README 文件，运行： $ git add README 跟踪所有的文件： $ git add --all 提交更新,git add 命令过后就要运行提交命令： $ git commit -m \u0026#34;此处添加本次提交的信息\u0026#34; 把修改的文件先提交到stage,然后再从stage提交到branch： $ git commit -a 将git add 和 git commit 命令合并，但此命令不适用于新建的文件（没有被add的文件）： $ git commit -am \u0026#34;此处添加本次提交的信息\u0026#34; 查看和对比修改的内容： $ git diff \u0026lt;filename\u0026gt; 查看提交历史： $ git log 创建名为branchName的分支： $ git brach branchName 放弃工作区和index的改动,HEAD指针仍然指向当前的commit： $ git reset --hard HEAD 回退到上一个版本(等价于 git reset \u0026ndash;hard HEAD~1)\n$ git reset --hard HEAD^ 回退到指定版本号状态 $ git reset --hard 20038 合并指定分支到当前分支（默认使用fast forward方式）： $ git merge \u0026lt;branch\u0026gt; 删除分支： $ git branch -d \u0026lt;branch\u0026gt; 从远程获取最新版本到本地仓库，并自动merge到本地分支： $ git pull origin master 丢弃你所有的本地改动与提交，可以到服务器上获取最新的版本并将你本地主分支指向到它： $ git fetch origin 以上是就是Git的常用命令，可以完成大部分版本控制任务。我接触Git不算太长时间，对Git的命令和流程还没有完全理解，只停留在会用的状态，做此总结算是一个巩固，希望以后能够更深刻的理解Git这个神器。\n我的GitHub账号https://github.com/w3cay\n","date":"2015年10月11日","externalUrl":null,"permalink":"/posts/%E6%88%91%E7%9A%84git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86/","section":"Posts","summary":"","title":"我的Git常用命令整理","type":"posts"},{"content":"今天无意间看到一个前端面试题，是考关于样式表规则特殊性计算的问题。CSS样式表规则排序问题关系到样式的渲染解析，如果不能很好的掌握特殊性的计算以及层叠规则，将会在编写CSS的时候出现编写的样式达不到预想效果的情况。所以今天花点时间总结一下CSS样式表的权重和层叠问题。 首先，每个选择器都有特殊性这个概念。对于每个选择器，用户代理会计算选择器的特殊性，根据特殊性的高低来进行比较。特殊性的值包括四个部分，如0，0，0，0 。具体计算规则如下：\n1.对于各个元素后加！important 的规则权重最高。 2.对于各个元素的内联样式，特殊性加 1，0，0，0 （就是1000）。 3.对于给定的各个ID属性值，特殊性加 0，1，0，0 （就是100）。 4.对于给定的各个类属性，属性选择或伪类，特殊性加 0，0，1，0 （就是10）。 5.对于给定的各个元素和伪元素，特殊性加 0，0，0，1（就是1） 。 6.结合符和通配符没有任何特殊性贡献。 计算出了各个选择器规则的特殊性，还不能最终确定页面的渲染规则，还需要根据层叠规则进行排序。 按权重排序：应用到同一元素的相同规则，如果其中一个规则有！important 声明，则这个规则胜出。 按来源排序：选择器的权重同时会受到规则来源来进行排序，总共分为5个级别，权重由大到小依次为： 1.读者的重要声明。 2.创作人员的重要声明。 3.创作人员的正常声明。 4.读者的正常声明。 5.用户代理的声明。 按特殊性排序：根据上文提出的规则特殊性计算规则进行特殊性计算，特殊性高的胜出。 按顺序排序：当出现两个权重，来源和特殊性都相同的规则，两者实力相当。那么就只能按照最后到的胜出，正所谓“长江后浪推前浪，一浪更比一浪强”。 小结，样式表的最终渲染结果就是各个声明规则按照权重，来源，特殊性，顺序来进行排序的，胜出的才能有“露脸”的机会。\n","date":"2015年9月21日","externalUrl":null,"permalink":"/posts/css%E6%A0%B7%E5%BC%8F%E8%A1%A8%E7%9A%84%E5%B1%82%E5%8F%A0%E8%A7%84%E5%88%99/","section":"Posts","summary":"","title":"CSS样式表的层叠规则","type":"posts"},{"content":"今天自己用原生js写了一个侧栏分享的小部件，其中用到的知识主要就是定时器，所以借此机会总结一下定时器的相关内容。 首先，定时器分为间歇调用定时器和超时调用定时器，两者之间很相似，命令基本一样。\n间歇调用的代码：\n//声明一个间歇定时器，并把ID赋值给intervalId。 var intervalId =setInterval(function(){ //执行代码 },1000); //清除定时器 clearInterval(intervalId); 超时定时器的代码：\n//声明一个超时定时器，并把ID赋值给timeoutId。 var timeoutId =\tsetTimeout(function(){ //执行代码 },1000); //清除定时器 clearTimeout(timeoutId); 说明：1.其中定时器第二个参数表示等待时间，以毫秒为单位。 2.每个定时器都会返回一个唯一ID，使用唯一ID来清除定时器。\n其次，两者之间有一些区别。使用间歇调用的时候，代码的执行是重复的，在不使用clearInterval的情况下，会一直进行下去。在使用超时调用的时候，代码的执行是单次的，所以clearTimeout的使用不是必须的。 最后，在实际的使用中，因为javascript的运行是单线程的，所以代码的运行需要进行排队。在当前代码的运行时间大于定时器的时间间隔时，可能会出现间隔被跳过或者多个定时器之间的间隔比预期的要小，这样就会产生很多麻烦。所以，在设置间隔调用定时器的时候要在每次触发定时器之前，清除当前的定时器，来预防定时器错乱。当设置超时定时器时，可以使用链式调用的方法解决（如下）： setTimeout(function(){ //执行代码 setTimeout(arguments.callee,1000); },1000);\n其中，《JS高程》建议，最佳实践是使用后面这种方式来设置重复定时器。但是，在我编写侧边分享模块的移入移出的时候，用后面的这种方式会出现像素移动的延迟，就是会多移动一段距离（也可能是我才疏学浅），所以我选择了间隔调用的方式。\n","date":"2015年9月21日","externalUrl":null,"permalink":"/posts/%E9%97%B4%E6%AD%87%E8%B0%83%E7%94%A8%E5%92%8C%E8%B6%85%E6%97%B6%E8%B0%83%E7%94%A8/","section":"Posts","summary":"","title":"间歇调用和超时调用","type":"posts"},{"content":"浮动是css中的定位模型之一，css属性名为float，其中有三个值（初始值为none）：\n**left **在包含框内向左浮动 right 在包含框内向右浮动 none 用于防止元素浮动 采用浮动布局的元素将会从正常文档流中删除，虽然它不在正常文档流中，但它还会影响正常流中的布局，是不是有点霸道？那是因为，浮动布局的本身作用是使文本能够环绕图片显示，只要元素设置了向左或向右的float属性，那么它周围的内容都会向它靠拢，注意是内容，元素的框还是无视它的，文本元素的边框不受浮动的影响，还是从正常文档流的左上角开始布局。\n如图： 那么，如何消除这种效果，并且浮动块可以保持浮动呢？那就需要用到clear属性了，其中有主要有这三个值：\nleft 清除元素左边的浮动 right 清除元素右边的浮动 both 清除元素两边的浮动 上一个例子，当将内容元素增加clear:left属性，就会出现这样的效果：\n当然使用clear：both 效果一样。如果是右浮动那就使用clear：right。\n下面一种情况，当包含块中两个元素都设置了浮动属性。 此时就会出现包含框Height值没有了，图中的高度是包含框Padding的值。这是因为当包含框中两个元素都设置了浮动属性，正常文档流中没有元素了，自然包含框就“瘪了”。这种情况也可以通过clear清除来修复这种情况，但是此时包含框中的两个元素都是浮动元素，肯定是本能清除它俩的，所以只能添加一个元素来进行清除。例如在包含框的最后增加\nhtml:\n\u0026lt;br class=\u0026#34;clear\u0026#34;/\u0026gt; css:\n.clear{ clear:both; } 然后，就正常了： 然而，这种方法并不好，每次清除都需要增加一个额外的标记。下面是更好的方法： IE下清除浮使元素haslayout就可以了，如宽度值，高度值，绝对定位，zoom，浮动本身都可以让元素haslayout。显然，首选zoom:1;不会干扰任何样式。非IE浏览器常用的是overflow属性，overflow:hidden; 所以兼容的做法是：\n.clear{overflow:hidden; zoom:1;} 小结，浮动定位用处非常的大，但是有时不是太好控制，所以当使用浮动的时候，要知道清除浮动的作用，让浮动之外的布局不受浮动影响。\n","date":"2015年9月20日","externalUrl":null,"permalink":"/posts/%E6%B5%AE%E5%8A%A8%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/","section":"Posts","summary":"","title":"浮动页面布局的那些事儿","type":"posts"},{"content":"引言：javascript的this关键字是个非常让人头疼的部分，this的指向真是让人“出乎意料”。看了《javascript高级程序设计》中的关于this对象的描述，差不多有了一个清晰的认识，为了防止忘记和分享所以做此总结。\nthis在不同情况下的指向 # ###全局环境中的this\nalert(this); //window 在全局环境中this指向全局对象，在浏览器中自然就指向Window。\n全局环境中函数调用 # var name=\u0026#34;Window\u0026#34;; function object(){ var name = \u0026#34;Object\u0026#34;; console.log(this.name); } object(); //Window 这里this指向了全局对象，即Window。在这个例子中即使object函数内部也定义了name属性，但是javascript中遵循谁调用了函数，那么这个this就指向谁。在严格模式中，则是undefined。\n作为对象的方法调用函数 # var name = \u0026#34;Window\u0026#34;; var o = { name : \u0026#34;object\u0026#34;, sayName : function(){ console.log(this.name); } } o.sayName(); //object 这次this指向的是定义的对象o，即当前对象。正好印证了谁调用指向谁的规律。\n作为构造函数 # new Person(); 函数内部的this指向新创建的对象。\n闭包内部函数 # var name = \u0026#34;Window\u0026#34;; var o = { name : \u0026#34;Object\u0026#34;, sayName : function(){ return function(){ return this.name; } } } console.log(o.sayName()()); //Window 存在闭包的情况下，函数的this指向与上面单纯的对象的函数的this指向又不太一样。这是为什么呢？通过参考《javascript高级程序设计》中的讲解加上我自己的理解，我的解释是这样的：闭包其实返回的就是一个匿名函数，而匿名函数的执行环境具有全局性，因此其this对象通常指向window。而又根据函数的执行环境，每次搜索变量时，只搜索到其活动对象为止（此活动对象为window），所以就无法访问其外部函数的变量了。\n那么如果想访问到外部作用域中的this，就需要将外部作用域中的this对象保存在闭包可以访问到的变量里。\nvar name = \u0026#34;Window\u0026#34;; var o = { name : \u0026#34;Object\u0026#34;, sayName : function(){ var that = this; //注意这里 return function(){ return that.name; } } } console.log(o.sayName()()); //Object 使用call和apply # call( thisArg [,arg1,arg2,… ] ); //参数列表，arg1,arg2,... apply(thisArg [,argArray] ); // 参数数组，argArray 两者都是将某个函数绑定到某个具体对象上使用，自然此时的this会被显式的设置为第一个参数。\n因本人还是个菜鸟，以上描述如有错误请评论指出\u0026hellip;\n","date":"2015年8月25日","externalUrl":null,"permalink":"/posts/this%E7%9A%84%E6%8C%87%E5%90%91%E9%97%AE%E9%A2%98/","section":"Posts","summary":"","title":"this的指向问题","type":"posts"},{"content":"","date":"2015年8月21日","externalUrl":null,"permalink":"/tags/css/","section":"Tags","summary":"","title":"CSS","type":"tags"},{"content":"","date":"2015年8月21日","externalUrl":null,"permalink":"/tags/css3/","section":"Tags","summary":"","title":"CSS3","type":"tags"},{"content":"选择器是css中一个很重要的内容，使用选择器可以提高在开发过程中修改样式表时的工作效率，并且使css的编写结构更加清晰和简单。css3在以前版本的基础上又添加的一些新的选择器，所以今天来总结一下css3选择器的特性及用法。\n属性选择器 # css3新增了3个属性选择器，分别是E[foo^=\u0026ldquo;bar\u0026rdquo;]、E[foo$=\u0026ldquo;bar\u0026rdquo;]、E[foo=\u0026ldquo;bar\u0026rdquo;]*。\nE[foo^=\u0026ldquo;bar\u0026rdquo;]: 匹配定义了foo属性，并且前缀为\u0026quot;bar\u0026quot;的E元素 E[foo$=\u0026ldquo;bar\u0026rdquo;]: 匹配定义了foo属性，并且后缀为\u0026quot;bar\u0026quot;的E元素 E[foo*=\u0026ldquo;bar\u0026rdquo;]: 匹配定义了foo属性，并且属性值包含\u0026quot;bar\u0026quot;的E元素 当省略属性选择器前不加\u0026quot;E\u0026quot;的时候，表示匹配任意类型元素。这三个属性选择器遵循惯用编码规则，选用\u0026quot;^\u0026quot;,\u0026quot;$\u0026quot;,\u0026quot;*\u0026ldquo;分别代表开始、结束、任意。\n结构伪类选择器 # E:root 匹配E元素所在文档的根元素，一般根元素就是Html E:nth-child(n) 匹配所在父节点中第n个位置的E元素(子节点))。 E:nth-last-child(n) 匹配所在父节点倒数第n个位置的E元素(与上面的类似) E:nth-of-type(n) 匹配所在父节点中第n个位置的同类型的E元素，其它类型元素不参与排序 E:nth-last-of-type(n) 匹配所在父节点中倒数第n个位置的同类型的E元素 E:last-child 义如其名，就是匹配所在父节点中最后一个E元素 E:first-of-type 匹配所在父节点中第一个同类型的E元素 E:last-of-type 匹配所在父节点中最后一个同类型的E元素 E:only-child 匹配所在父节点中只包含一个元素，且该元素正是E E:only-of-type 匹配所在父节点中包含一个同类型元素，且该元素是E E:empty 匹配E元素，且该元素不含子节点注意文本也属于节点 以上，n可以是从1开始的数字，也可以是公式，如2n(匹配偶数)，2n+1(匹配奇数)，也可以是关键字odd(匹配奇数)，even(匹配偶数\nUI伪类选择器 # 在css3中除了结构性伪类选择器，还有UI伪类选择器。这些选择器的共同特征是：指定的样式只有在处于某种状态时才会起作用。\nE:enabled 匹配用户界面上所有可用的元素E E:disabled 匹配用户界面上所有不可用的元素E E:checked 匹配用户界面上处于选中状态的元素E 其它选择器 # E~F 兄弟选择器，匹配E元素后的所有F元素，两者处于同一级结构上。 E:not(s) 否定选择器，匹配除了符合\u0026quot;s\u0026quot;选择符的E元素,\u0026ldquo;s\u0026quot;是一个简单结构选择器。 E:target 匹配被URL选中的E元素，如\u0026quot;blog.caydock.com/#element\u0026quot;会匹配id=\u0026ldquo;element\u0026quot;的E元素。 ","date":"2015年8月21日","externalUrl":null,"permalink":"/posts/css3%E9%80%89%E6%8B%A9%E5%99%A8%E6%B8%85%E5%8D%95/","section":"Posts","summary":"","title":"CSS3选择器清单","type":"posts"},{"content":"","date":"2015年8月21日","externalUrl":null,"permalink":"/tags/%E9%80%89%E6%8B%A9%E5%99%A8/","section":"Tags","summary":"","title":"选择器","type":"tags"},{"content":"","externalUrl":null,"permalink":"/en/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/en/","section":"Blowfish","summary":"","title":"Blowfish","type":"page"},{"content":"","externalUrl":null,"permalink":"/en/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","externalUrl":null,"permalink":"/en/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","externalUrl":null,"permalink":"/en/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"}]